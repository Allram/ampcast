"use strict";(globalThis.webpackChunkampcast=globalThis.webpackChunkampcast||[]).push([[595],{7069:(r,n,e)=>{e.r(n),e.d(n,{default:()=>t});const t=[{id:"ldSGRW",name:"25 boxes and a tunnel by movAX13h",shader:"// https://www.shadertoy.com/view/ldSGRW\r\n// 25 boxes, a tunnel based on voronoi, bit encoded patterns, script for 80 seconds (music)\r\n// fragment shader by movAX13h, November 2013\r\n\r\n// NOTE: Patterns start at ~45 seconds.\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nfloat rand(float n)\r\n{\r\n    return fract(sin(n * 12.9898) * 43758.5453);\r\n}\r\n\r\nvec2 rand2(vec2 p)\r\n{\r\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\r\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat pattern(float n, vec2 p)\r\n{\r\n\tp = p * 4.0;\r\n\tp = floor(p + 2.5);\r\n\r\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\r\n\t{\r\n\t\tfloat k = p.x + p.y*5.0;\r\n\t\tif (int(mod(n/(pow(2.0,k)),2.0)) == 1) return 0.0;\r\n\t}\r\n\r\n\treturn 1.0;\r\n}\r\n\r\nstruct Cell\r\n{\r\n\tfloat d;\r\n\tvec2 hash;\r\n\tvec2 pos;\r\n};\r\n\r\nCell Cells(in vec2 p, in float numCells, bool bump)\r\n{\r\n\tp *= numCells;\r\n\r\n\tfloat d = 1.0e20;\r\n\tvec2 hash;\r\n\tvec2 pos;\r\n\r\n\tfor (int dx = -1; dx <= 1; dx++)\r\n\tfor (int dy = -1; dy <= 1; dy++)\r\n\t{\r\n\t\tvec2 tp = floor(p) + vec2(dx, dy);\r\n\t\tvec2 h = rand2(vec2(mod(tp.x, numCells), tp.y)); // repeat x\r\n\t\tfloat m = length(p - tp - h);\r\n\r\n\t\tif (m < d)\r\n\t\t{\r\n\t\t\td = m;\r\n\t\t\thash = h;\r\n\t\t\tpos = tp;\r\n\t\t}\r\n\t}\r\n\r\n\tif (bump) return Cell(d, hash, pos);\r\n\treturn Cell(1.0-d, hash, pos);\r\n}\r\n\r\n\r\nfloat sampleMusic(float f, float bands)\r\n{\r\n\tf = floor(f*bands)/bands;\r\n\tfloat fft = texture( iChannel0, vec2(f,0.0) ).x;\r\n\treturn fft;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.25 * (\r\n\t\ttexture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\n\r\n#define L_hi 1613493.0\r\n#define L_smile 10813998.0\r\n#define L_I 14815374.0\r\n#define L_heart 11533764.0\r\n#define L_S 15793695.0\r\n#define L_T 462976.0\r\n\r\n#define L_NONE 0.0\r\n#define L_RANDOM 1.0\r\n\r\nfloat time;\r\n\r\nbool openTunnel = false;\r\nbool bumpTunnel = false;\r\nfloat boxSymbol = L_RANDOM;\r\n\r\nvec4 scene(vec3 p)\r\n{\r\n\tfloat tunnelRadius = 0.38;\r\n\tfloat numCells = 8.0;\r\n\r\n\tfloat d, d1;\r\n\tvec3 q = p;\r\n\r\n\tvec3 col = vec3(0.1, 0.7, 1.0);\r\n\td = 10000.0;\r\n\r\n \t// tunnel\r\n\t#if 1\r\n\tvec2 uv = vec2((atan(p.y, p.x) + 3.14159265) / 6.283185307, -time*0.6 + p.z*0.4);\r\n\tCell cell = Cells(uv, numCells, bumpTunnel);\r\n\tq.xy *= 1.0 + cell.d*0.1;\r\n\td = max(length(q.xy) - tunnelRadius+0.01,-(length(q.xy) - tunnelRadius));\r\n\tif (openTunnel) d = max(-sdBox(p-vec3(-1.2, 0.0, 0.0), vec3(1.0, 1.0, 10.0)), d);\r\n\tfloat m = sampleMusic() * (1.0+smoothstep(0.4, 0.6, sampleMusic(cell.hash.x * cell.hash.y, 4.0)));\r\n\tvec3 c = m*vec3(cell.hash.x*0.9, cell.hash.y*0.3, 0.11)*cell.d;\r\n\tcol = mix(col, c, smoothstep(0.1, 0.0, d));\r\n\t#endif\r\n\r\n\t// letter boxes\r\n\t#if 1\r\n\tfloat ltime = mod(time, 10.0);\r\n\r\n\tif (boxSymbol > 0.0)\r\n\t{\r\n\t\tfor(int i = 0; i < 25; i++)\r\n\t\t{\r\n\t\t\tvec3 pos;\r\n\r\n\t\t\tif (boxSymbol < 1.1) // random boxes\r\n\t\t\t{\r\n\t\t\t\tltime = time*3.0 + float(i)*20.134;\r\n\r\n\t\t\t\tfloat r = rand(float(i)*20.33);\r\n\t\t\t\tfloat z = -6.0+mod(ltime*(r + 0.5), 15.0);\r\n\r\n\t\t\t\tif (!openTunnel && z > 2.0) continue;\r\n\r\n\t\t\t\tpos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);\r\n\t\t\t\td1 = sdBox(p-pos,  vec3(0.009)); // ugly boxes\r\n\t\t\t\tif (d1 < d)\r\n\t\t\t\t{\r\n\t\t\t\t\td = d1;\r\n\t\t\t\t\tcol = vec3(0.1, 0.6, 0.9)*(r+0.2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse // symbol mode\r\n\t\t\t{\r\n\t\t\t\tfloat z = 0.5+0.2*tan(-time - float(i)*0.04);\r\n\t\t\t\tif (z > 1.0) continue;\r\n\r\n\t\t\t\tvec3 shift = min(z-0.5, 0.0) * vec3(0.08*sin(time + 0.2*float(i)), 0.08*cos(time + 0.4 * float(i)), 0.0);\r\n\t\t\t\tpos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);\r\n\t\t\t\td1 = sdBox(p-pos-shift,  vec3(0.009)); // ugly boxes\r\n\t\t\t\tif (d1 < d)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat lv = pattern(boxSymbol, (p.xy-shift.xy)*6.2);\r\n\t\t\t\t\td = d1;\r\n\t\t\t\t\tif (lv > 0.5) col = vec3(0.216, 0.106, 0.173);\r\n\t\t\t\t\telse col = vec3(0.820, 0.839, 0.906);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t#endif\r\n\treturn vec4(col, d);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\r\n\r\n    float focus = 3.14;\r\n    float far = 5.5;\r\n\r\n\ttime = iTime;\r\n\r\n\tvec3 ct = vec3(0.0);\r\n\tvec3 cp;\r\n\tvec3 cu  = vec3(0.0, 1.0, 0.0);\r\n\r\n\tif (time < 12.7)\r\n\t{\r\n\t\tcp = vec3(0.2*sin(time*0.4), -0.02+0.2*cos(time*0.2), 1.5);\r\n\t}\r\n\telse if (time < 27.8)\r\n\t{\r\n\t\tcp = vec3(-0.2*sin(time*0.4), 0.02+0.2*sin(time*0.2), 1.5);\r\n\t}\r\n\telse if (time < 35.4)\r\n\t{\r\n\t\tbumpTunnel = true;\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcp = vec3(0.6, sin(time*0.4-35.4), 1.5);\r\n\t}\r\n\telse if (time < 44.9)\r\n\t{\r\n\t\topenTunnel = true;\r\n\t\tcp = vec3(-2.0, 0.0, 3.5);\r\n\t}\r\n\telse if (time < 45.2)\r\n\t{\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t}\r\n\telse if (time < 63.7)\r\n\t{\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t\tcu  = vec3(0.1*sin(time), 1.0, 0.1*cos(time));\r\n\r\n\t\tfloat id = mod(floor((time - 45.2) / 3.1415), 6.0);\r\n\t\tif (id == 0.0) boxSymbol = L_hi;\r\n\t\telse if (id == 1.0) boxSymbol = L_smile;\r\n\t\telse if (id == 2.0) boxSymbol = L_I;\r\n\t\telse if (id == 3.0) boxSymbol = L_heart;\r\n\t\telse if (id == 4.0) boxSymbol = L_S;\r\n\t\telse if (id == 5.0) boxSymbol = L_T;\r\n\t}\r\n\telse if (time < 79.3)\r\n\t{\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcu  = vec3(sin(time), 1.0, cos(time));\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tboxSymbol = L_RANDOM;\r\n\t\tcp = vec3(0.2*sin(time*0.4), -0.02+0.2*cos(time*0.2), 1.5);\r\n\t\tcu  = vec3(sin(time*0.8), 1.0, cos(time*0.6));\r\n\t}\r\n\r\n\t#if 0\r\n\tif (iMouse.z > 0.0) // debug\r\n\t{\r\n\t\tfloat d = (iResolution.y-iMouse.y)*0.01+3.0;\r\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, .0, cos(iMouse.x*0.01)*d);\r\n\t}\r\n\t#endif\r\n\r\n\tvec3 cd = normalize(ct-cp);\r\n\tvec3 cs = cross(cd, cu);\r\n\tvec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\r\n\r\n    vec4 s;\r\n\tfloat dist = 0.0;\r\n\tvec3 ray = cp;\r\n\r\n    for(int i=0; i < 40; i++)\r\n\t{\r\n        s = scene(ray);\r\n\r\n        dist += s.w;\r\n        ray += dir * s.w;\r\n\r\n        if(s.w < 0.01) break;\r\n\r\n        if(dist > far)\r\n\t\t{\r\n\t\t\tdist = far;\r\n\t\t\tbreak;\r\n\t\t}\r\n    }\r\n\r\n    float b = 1.0 - dist/far;\r\n\tvec3 col = b * s.rgb;\r\n\r\n\t// fake lights\r\n\tcol *= pow(1.3 + smoothstep(0.6, 0.0, abs(sin(ray.z+time*2.0))), 2.0);\r\n\r\n\t// vignetting & grain\r\n\tcol *= 1.0-smoothstep(0.0, 2.0, length(pos.xy));\r\n\tcol -= 0.03*rand(pos.xy);\r\n\r\n\tfragColor = vec4(col*1.2, 1.0);\r\n}\r\n"},{id:"sslXzX",name:"MandelKoch - Music Visualiser by Pelegefen",shader:"// https://www.shadertoy.com/view/sslXzX\r\n// ----------------CAUTION!!!--- FLASHING BRIGHT LIGHTS!!!-------------------------\r\n\r\n\r\n\r\n// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://iquilezles.org/articles/msetsmooth\r\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\r\n//music - Sajanka (Official) Sajanka - Sun Is Coming\r\n\r\n//Some notes - color is determined by date and not time - hour of day dependent.\r\n//Move the mouse on the Y axis to change the symmetry.\r\n\r\n//----------------------------------------------------------------------------------\r\n\r\n//uncomment to sample audio input from MIC instead of SoundCloud.\r\n//#define MIC_INPUT\r\n\r\n//comment to make it less trippy and noisy.\r\n//#define EXTRA_DMT\r\n\r\n\r\n#define PI 3.14159265359\r\n\r\n\r\n\r\n#define date iDate\r\n#define time iTime\r\n#define resolution iResolution\r\n\r\nfloat freqs[4];\r\n\r\n\r\nvec2 rot(vec2 p,float a){\r\n\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n\r\n    mat2 m = mat2(c,-s,s,c);\r\n\r\n    p*=m;\r\n    return p  ;\r\n}\r\n\r\nfloat localTime(){\r\n\r\nfloat d = date.w / date.x;\r\nreturn d;\r\n\r\n}\r\n\r\nvec3 randomCol(float sc){\r\n\r\n float d = localTime();\r\n\tfloat r = sin(sc * 1. * d)*.5+.5;\r\n\tfloat g = sin(sc * 2. * d)*.5+.5;\r\n\tfloat b = sin(sc * 4. * d)*.5+.5;\r\n\r\n\tvec3 col = vec3(r,g,b);\r\n\tcol = clamp(col,0.,1.);\r\n\r\n\treturn col;\r\n\t}\r\n\r\n\r\n//--------------------------------------------------mandelbrot generator-----------https://iquilezles.org/articles/msetsmooth\r\n\r\n\tfloat mandelbrot(vec2 c )\r\n{\r\n    #if 1\r\n    {\r\n        float c2 = dot(c, c);\r\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\r\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\r\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\r\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\r\n    }\r\n    #endif\r\n\r\n\r\n    const float B = 128.0;\r\n    float l = 0.0;\r\n    vec2 z  = vec2(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\r\n        if( dot(z,z)>(B*B) ) break;\r\n        l += 1.0;\r\n    }\r\n\r\n    if( l>255.0 ) return 0.0;\r\n\r\n\r\n    // equivalent optimized smooth interation count\r\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\r\n\r\n\r\n\r\n     return sl;\r\n }\r\n\r\n\r\nvec3 mandelbrotImg(vec2 p)\r\n{\r\n\r\n    //uncomment to see unmaped set\r\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    float mtime =  time;\r\n    mtime -= freqs[3];\r\n    float zoo = 0.62 + 0.38*cos(.1*mtime);\r\n   float coa = cos( 0.015*(1.0-zoo)*mtime );\r\n   float sia = sin( 0.015*(1.0-zoo)*mtime );\r\n   zoo = pow( zoo,6.0);\r\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\r\n   vec2 c = vec2(-.745,.186) + xy*zoo;\r\n\r\n        float l = mandelbrot(c);\r\n\r\n\r\n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\r\n    #ifdef EXTRA_DMT\r\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\r\n    #else\r\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 * randomCol(.1));\r\n    #endif\r\n    vec3 col = mix(col1,col2,sin(mtime)*.5+.5);\r\n\r\n\r\n\r\n\r\nreturn col;\r\n}\r\n\r\n//-----------------functions-----------\r\n\r\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvec2 N(float angle) {\r\n    return vec2(sin(angle), cos(angle));\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n//--------get soundtrack frequencies----\r\n\r\n\r\n    #ifdef MIC_INPUT\r\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\r\n    #else\r\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n    #endif\r\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\r\n\r\n//--------image part---------\r\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\r\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\r\n\tvec2 ouv = uv;\r\n    //uv.y -= .05;\r\n\r\n    uv = rot(uv,(sin(iTime*.1) / freqs[0]*.1  ) * PI  ) ;\r\n\tuv *= 4.0 - (avgFreq * 1.5  );\r\n\r\n    uv.x = abs(uv.x);\r\n\r\n    vec3 col = vec3(0);\r\n    float d;\r\n\r\n    float angle = 0.;\r\n    vec2 n = N((5./6.)*3.1415);\r\n\r\n    uv.y += tan((5./6.)*3.1415)*.5;\r\n   \td = dot(uv-vec2(.5, 0), n);\r\n    uv -= max(0.,d)*n*2.;\r\n\r\n    float scale = 1.;\r\n\r\n    n = N( freqs[0]*(2./3.)*3.1415);\r\n    uv.x += .5;\r\n    for(int i=0; i<10; i++) {\r\n        uv *= 3.;\r\n        scale *= 3.;\r\n        uv.x -= 1.5;\r\n\r\n        uv.x = abs(uv.x);\r\n        uv.x -= .5;\r\n        d = dot(uv, n);\r\n        uv -= min(0.,d)*n*2.;\r\n    }\r\n\r\n    d = length(uv/ clamp(freqs[2],0.1,.9 )- vec2(clamp(uv.x,-1., 1.), 0));\r\n    col += smoothstep(10./resolution.y, .0, d/scale);\r\n    uv /= scale;\t// normalization\r\n\r\n\r\n\tvec3 manCol = mandelbrotImg(uv);\r\n\t col += manCol;\r\n\r\n\r\n \t\t// vignette effect\r\n\t  col *= 1.0 - 0.5*length(uv *0.5) * freqs[1];\r\n\r\n\r\n    fragColor = vec4( col,1.0);\r\n}\r\n"},{id:"XsXXDn",name:"Creation by Silexars / Danilo Guanabara",shader:"// https://noisehack.com/build-music-visualizer-web-audio-api/ (adapted from)\r\n// https://www.shadertoy.com/view/XsXXDn\r\n// http://www.pouet.net/prod.php?which=57245\r\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\r\n    vec3 c;\r\n    float z = 0.1 * iTime;\r\n    vec2 uv = fragCoord.xy / iResolution;\r\n    vec2 p = uv - 0.5;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float l = 0.2 * length(p);\r\n    for (int i = 0; i < 3; i++) {\r\n        z += 0.07;\r\n        uv += p / l * (sin(z) + 1.0) * abs(sin(l * 9.0 - z * 2.0));\r\n        c[i] = 0.01 / length(abs(mod(uv, 1.0) - 0.5));\r\n    }\r\n    float intensity = texture(iChannel0, vec2(l, 0.5)).x;\r\n    fragColor = vec4(c / l * intensity, iTime);\r\n}\r\n"},{id:"MdXGz4",name:"Nautilus by weyland",shader:"// Nautilus by weyland\r\n// https://www.shadertoy.com/view/MdXGz4\r\n\r\n\r\n// Nautilus 1k ...\r\n\r\nfloat e(vec3 c)\r\n{\r\n\tc=cos(vec3(cos(c.r+iTime/8.)*c.r-cos(c.g+iTime/9.)*c.g,c.b/3.*c.r-cos(iTime/7.)*c.g,c.r+c.g+c.b/1.25+iTime));\r\n\treturn dot(c*c,vec3(1.))-1.0;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 c=-1.+2.*fragCoord.xy / iResolution.xy;\r\n    vec3 o=vec3(c.r,c.g+cos(iTime/2.)/30.,0),g=vec3(c.r+cos(iTime)/30.,c.g,1)/64.;\r\n    float m=1.0;\r\n\tfloat t=0.0;\r\n    for(int j=0;j<333;j++)\r\n    {\r\n        if( m>.4)\r\n\t\t{\r\n            t = (1.0+float(j))*2.0;\r\n   \t\t\tm = e(o+g*t);\r\n\t\t}\r\n    }\r\n    vec3 r=vec3(.1,0.,0.);\r\n\tvec3 n=m-vec3( e(vec3(o+g*t+r.rgg)),\r\n                   e(vec3(o+g*t+r.grg)),\r\n                   e(vec3(o+g*t+r.ggr)) );\r\n    vec3 v=vec3(dot(vec3(0,0,-.5),n)+dot(vec3(0.0,-.5,.5),n));\r\n    // edited below (ampcast)\r\n    vec2 uv = fragCoord.xy / iResolution;\r\n    vec2 p = uv - 0.5;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float l = 0.1 * length(p);\r\n    float intensity = texture(iChannel0, vec2(l, 0.5)).x;\r\n\tfragColor=vec4(v + intensity * vec3(.1+cos(iTime/14.)/8.,.1,.1-cos(iTime/3.)/19.)*(t/41.),iTime);\r\n}\r\n"},{id:"4sXfzj",name:"Quasicrystal Visualizer by Ebanflo",shader:"// Quasicrystal Visualizer by Ebanflo\r\n// https://www.shadertoy.com/view/4sXfzj\r\n\r\n\r\nconst int numWaves = 6;\r\nconst float numStripes = 1.0;\r\nconst float numFreqs = 8.0;\r\nconst float meanFreq = 4.0;\r\nconst float stdDev = 2.0;\r\nconst float period = 3.0;\r\nconst float pi = 4.0 * atan(1.0);\r\nconst float pi2 = 2.0 * pi;\r\nconst float ln2 = log(2.0);\r\nconst float mean = meanFreq * .69314718;\r\n\r\nfloat wavething(int n, float x){\r\n    float l = ln2 * float(n) + log(x);\r\n    l -= mean;\r\n    return exp(-l * l / stdDev) / 2.0;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    fragColor = vec4(0.0);\r\n    float scale = exp2(-fract(iTime / period));\r\n    float sum1 = 0.0;\r\n    for(int n = 0; n < int(numFreqs); n++){\r\n        sum1 += wavething(n, scale + 0.5*float(n));\r\n    }\r\n    vec2 xy = pi2 * numStripes\r\n        * ((2.0 * fragCoord - iResolution.xy) / iResolution.y);\r\n\r\n    float sum2 = 0.0;\r\n    for(int n = 0; n < numWaves; n++){\r\n        float theta = pi * float(n) / float(numWaves);\r\n        vec2 waveVec = vec2(cos(theta), sin(theta));\r\n        float phase = dot(xy, waveVec);\r\n        for(int k = 0; k < int(numFreqs); k++){\r\n            sum2 += cos(phase * scale * exp2(float(k))) * wavething(k, scale + 0.5*float(n));\r\n        }\r\n    }\r\n    fragColor += vec4(1.0 - sum2 / sum1);\r\n    xy /= pi2 * numStripes;\r\n    float r = length(xy);\r\n    fragColor.x *= texture(iChannel0, vec2(.161616 * r, .2)).x;\r\n    fragColor.y *= texture(iChannel0, vec2(.161616 * r + .161616, .2)).x;\r\n    fragColor.z *= texture(iChannel0, vec2(.161616 * r + .333333, .2)).x;\r\n    fragColor = 1.0 - fragColor;\r\n    fragColor = 1.0 - (r + 1.0) * fragColor;\r\n    if(length(fragColor) > 3.0) fragColor = vec4(0.0);\r\n}\r\n"},{id:"ttfGzH",name:"🎶 Rainbow soundviz 🎶 by avin",shader:"// https://www.shadertoy.com/view/ttfGzH\r\n#define PI 3.1415926\r\n#define PI2 6.2831852\r\n\r\n#define hue(h)clamp(abs(fract(h + vec4(3, 2, 1, 0) / 3.0) * 6.0 - 3.0) - 1.0 , 0.0, 1.0)\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n {\r\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\r\n\r\n    float CIRCLES = 20.0;\r\n    float cS = 0.375;\r\n\r\n    float sm = 1.0 / iResolution.y * 2.0; // smooth\r\n    float ps = 1.0 / iResolution.y * sqrt(iResolution.y) * 0.225; // circle thin\r\n\r\n    float d = length(uv);\r\n\r\n    float a = atan(uv.y, uv.x);\r\n    a = a < 0.0 ? PI + (PI - abs(a)) : a;\r\n\r\n    float lPos = a /PI2;\r\n\r\n    float m = 0.0;\r\n    float partSize = 1.0 / CIRCLES;\r\n    vec3 col;\r\n    for (float i = 20.0; i > 1.0; i -= 1.0) {\r\n        float ilPos = fract(lPos + i*0.1 + iTime * 0.1);\r\n        float cPos = partSize * i + ilPos * partSize;\r\n        float invPos = partSize * (i + 1.0) - ilPos * partSize;\r\n        float nzF = (1.0 - ilPos);\r\n        float mP0 = texture(iChannel0, vec2(partSize * i, 0.0)).x;\r\n        float mP = texture(iChannel0, vec2(cPos, 0.0)).x;\r\n        float mPInv = texture(iChannel0, vec2(invPos, 0.0)).x;\r\n\r\n        mP = (mP + mPInv) / 2.0;\r\n\r\n        float rDiff = i*(1.0 / CIRCLES * 0.35);\r\n        float r = mP * (1.0 / CIRCLES * 3.0) - rDiff;\r\n\r\n        float subm = smoothstep(cS - ps + r, cS - ps + sm + r, d) * smoothstep(cS + r, cS - sm + r, d);\r\n\r\n        if (subm > 0.0) {\r\n            col = hue(i / CIRCLES * 0.5 + iTime * 0.05 + mP0 * 0.84).rgb;\r\n        }\r\n\r\n        m += subm;\r\n    }\r\n\r\n    m = clamp(m, 0.0, 1.0);\r\n\r\n    float r = (sin(iTime * 0.5) * 0.5 + 0.5);\r\n    float b = (cos(iTime * 0.5) * 0.5 + 0.5);\r\n    vec3 backCol = vec3(r, 0.0, b) * length(uv * 0.75) * 0.5;\r\n\r\n    col = mix(backCol, col, m);\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"wd3XzS",name:"Audio-Visualizer by CoolerZ",shader:"// https://www.shadertoy.com/view/wd3XzS\r\nfloat sigmoid(float x)\r\n{\r\n    return 1. / (1. + exp(x));\r\n}\r\n\r\nvec3 sigmoid(vec3 xyz)\r\n{\r\n    return vec3(sigmoid(xyz.x), sigmoid(xyz.y), sigmoid(xyz.z));\r\n}\r\n\r\nfloat sample_at(float f)\r\n{\r\n    return texture(iChannel0, vec2(f / 16.0, 0.)).x;\r\n}\r\n\r\nfloat sample_multiple(float f)\r\n{\r\n    float delta = .1;\r\n    return 0.2 * (sample_at(f - 2. * delta) + sample_at(f - delta) + sample_at(f) + sample_at(f + delta) + sample_at(f + 2. * delta));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord.xy - 0.5) / iResolution.xy;\r\n    uv = 2. * uv - 1.;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    vec2 center = vec2(0.);// 0.5 * vec2(cos(iTime), sin(iTime));\r\n    float d = length(uv - center);\r\n\r\n    float amplitude = sample_multiple(d * d);\r\n    d -= amplitude;\r\n    float weird = sigmoid(abs(uv.x) * abs(uv.y));\r\n    float speed = 6. * amplitude * sin(iTime * weird * 0.005) * 0.001;\r\n    float dist_diagonal = abs(abs(uv.x) - abs(uv.y));\r\n    dist_diagonal += d * amplitude;\r\n    dist_diagonal *= dist_diagonal;\r\n    amplitude += .1 / (.1 + smoothstep(1., 0.1, dist_diagonal));\r\n    float brightness = 3. * amplitude * sigmoid(sin(d * d * 16. - speed * iTime + 2. * speed * amplitude));\r\n\r\n    vec3 col = sigmoid(vec3(uv, sin(iTime)));\r\n\r\n    fragColor = vec4(col * brightness,1.0);\r\n}\r\n"},{id:"4sVBWy",name:"Radiant by Hazel Quantock",shader:"// https://www.shadertoy.com/view/4sVBWy\r\n// Radiant Music Visualiser\r\n// by Hazel Quantock 2018\r\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\r\n\r\n    float l = length(uv)/length(iResolution.xy/iResolution.y);\r\n    float a = atan(uv.x,uv.y)+iTime;\r\n    float s = texture(iChannel0,vec2(abs(fract(5.*a/6.283)*2.-1.),.75)).r;\r\n\r\n    float A = .4;\r\n    float B = .45;\r\n    if ( iMouse.z > 0. )\r\n    {\r\n        A = iMouse.x / iResolution.x; // strength of chromatic dispersion\r\n        B = iMouse.y / iResolution.y; // strength of waveform\r\n    }\r\n    A *= A; // apply a curve so mouse movements feel better\r\n    B *= B;\r\n\r\n    fragColour.r = texture(iChannel0,vec2(pow(mix(mix(l,.0,A),    s ,B),2.),.25)).r;\r\n    fragColour.g = texture(iChannel0,vec2(pow(mix(mix(l,.5,A),(1.-s),B),2.),.25)).r;\r\n    fragColour.b = texture(iChannel0,vec2(pow(mix(mix(l,1.,A),    s ,B),2.),.25)).r;\r\n\r\n    // tweak the contrast\r\n    fragColour.rgb = smoothstep(.05,1.,fragColour.rgb+.2*l);\r\n    fragColour.rgb = pow( fragColour.rgb, vec3(2) );\r\n\r\n    fragColour.a = 1.;\r\n}\r\n"},{id:"ltc3WH",name:"ambilight visualization 2.0 by MillhausVKodi",shader:'// https://www.shadertoy.com/view/ltc3WH\r\nconst float bands = 20.0;\r\nconst float leds = 25.0;\r\nconst float colorRange = 0.3; // >0. (=1. full color range, >1. repeat colors)\r\n\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // middle = (0/0)\r\n    vec2 k=(fragCoord.xy-.5*iResolution.xy)/(max(iResolution.x,iResolution.y));\r\n\r\n\r\n\r\n    //distance from the middle\r\n    float dis = distance(k , vec2(0));\r\n\r\n    //and approximated by "leds"\r\n    float disA = floor(dis*leds)/leds;\r\n    //disA = dis;\r\n\r\n\r\n    //degree from bottom 0 and top 1.0.  /left right symetric\r\n    float deg = acos(k.y/dis)/3.14;\r\n\r\n    //and approximated by "bands"\r\n    float degA = floor(deg*bands)/bands;\r\n\r\n\r\n\r\n   //colorwheel, dark in the middle, changing colors over time\r\n    vec3 color = hsv2rgb(  vec3( degA*colorRange + iTime*0.07 , 1.0 , smoothstep(0.0, 0.6, disA) )  );\r\n\r\n\r\n\r\n\t//brightness of a band by fourier (degree to frequency / magnitude to brightness)\r\n    float bandBrightness = texture( iChannel0, vec2(degA,0.25)).x;\r\n\r\n\r\n    //more blinky blinky x^2\r\n    color*=bandBrightness*bandBrightness;\r\n\r\n    //brighter\r\n    color*=4.;\r\n\r\n\r\n\r\n    float deltaDeg = fract((deg-degA)*bands) - 0.5;\r\n    float deltaDis = fract((dis-disA)*leds) - 0.5;\r\n\r\n    float shape = smoothstep(0.5, 0.35, abs(deltaDeg)) *\r\n                smoothstep(0.5, 0.35, abs(deltaDis));\r\n\r\n\r\n    color*=shape;\r\n\r\n\t//return\r\n    fragColor = vec4(color, 1.0);\r\n}\r\n'},{id:"Xd2cRG",name:"dot grid thing by laney",shader:"// https://www.shadertoy.com/view/Xd2cRG\r\n\r\n\r\nfloat circle(vec2 p, float radius) {\r\n \treturn length(p)-radius;\r\n}\r\n\r\nvec2 dist(vec2 p, vec2 ns, vec2 split, float totalSquares) {\r\n \tfloat amp1 = texture(iChannel0, vec2((ns.x + ns.y*split.x)/totalSquares, 0.25)).x;\r\n    float amp2 = texture(iChannel0, vec2(mod(ns.x + ns.y*split.x +1., totalSquares)/totalSquares, 0.25)).x;\r\n \treturn vec2(circle(p, 0.5 + 0.9*amp1), circle(p, 0.40 + 0.60*amp2));\r\n\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float res = exp( -k*a ) + exp( -k*b );\r\n    return -log( res )/k;\r\n}\r\n\r\nconst float ySplit = 10.0;\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\r\n    vec2 split = vec2(floor(aspect*vec2(ySplit)));\r\n    float totalSquares = split.x*split.y;\r\n\tvec2 ns = floor(uv*split);\r\n    vec2 p = vec2(fract(uv*split))*2.0-vec2(1.0);\r\n\r\n\r\n   \tvec2 c = dist(p, ns, split, totalSquares);\r\n   \tvec2 w = dist(p+vec2(2.0,0.0), ns+vec2(-1.0,0.0), split, totalSquares);\r\n   \tvec2 nw = dist(p+vec2(2.0,-2.0), ns+vec2(-1.0,1.0), split, totalSquares);\r\n   \tvec2 ne = dist(p+vec2(-2.0,-2.0), ns+vec2(1.0,1.0), split, totalSquares);\r\n   \tvec2 sw = dist(p+vec2(2.0,2.0), ns+vec2(-1.0,-1.0), split, totalSquares);\r\n   \tvec2 se = dist(p+vec2(-2.0,2.0), ns+vec2(1.0,-1.0), split, totalSquares);\r\n   \tvec2 e = dist(p+vec2(-2.0,0.0), ns+vec2(1.0,0.0), split, totalSquares);\r\n   \tvec2 s = dist(p+vec2(0.0,2.0), ns+vec2(0.,-1.0), split, totalSquares);\r\n   \tvec2 n = dist(p+vec2(0.0,-2.0), ns+vec2(0.,1.0), split, totalSquares);\r\n\r\n    float k = 3.0;\r\n    float d1 = smin(c.x, w.x, k);\r\n    d1 = smin(d1, e.x, k);\r\n    d1 = smin(d1, n.x, k);\r\n    d1 = smin(d1, s.x, k);\r\n    d1 = smin(d1, nw.x, k);\r\n    d1 = smin(d1, ne.x, k);\r\n    d1 = smin(d1, sw.x, k);\r\n    d1 = smin(d1, se.x, k);\r\n\r\n    float d2 = smin(c.y, w.y, k);\r\n    d2 = smin(d2, e.y, k);\r\n    d2 = smin(d2, n.y, k);\r\n    d2 = smin(d2, s.y, k);\r\n    d2 = smin(d2, nw.y, k);\r\n    d2 = smin(d2, ne.y, k);\r\n    d2 = smin(d2, sw.y, k);\r\n    d2 = smin(d2, se.y, k);\r\n\r\n\tfragColor =\r\n        vec4(0.1,0.1,0.1,1.0) *  (1.0 - d1) +\r\n        vec4(.3,0.5,0.3,1.0) *  (1.0 - smoothstep(0., 0.15, d1)) +\r\n        vec4(0.5,0.2,0.1,1.0) *  (1.0 - smoothstep(0., 0.1, d2));\r\n\r\n}\r\n"},{id:"llXBWB",name:"Bubbles music visualizer by liyouvane",shader:"// https://www.shadertoy.com/view/llXBWB\r\n// reference : https://github.com/ashima/webgl-noise\r\n// reference : I/O fragment shader by movAX13h, August 2013\r\n// https://www.shadertoy.com/view/XsfGDS\r\n\r\n#define SHOW_BLOCKS\r\n\r\nvec4 mod289(vec4 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x)\r\n{\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nvec2 fade(vec2 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\n// Classic Perlin noise\r\nfloat cnoise(vec2 P)\r\n{\r\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\r\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\r\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\r\n  vec4 ix = Pi.xzxz;\r\n  vec4 iy = Pi.yyww;\r\n  vec4 fx = Pf.xzxz;\r\n  vec4 fy = Pf.yyww;\r\n\r\n  vec4 i = permute(permute(ix) + iy);\r\n\r\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\r\n  vec4 gy = abs(gx) - 0.5;\r\n  vec4 tx = floor(gx + 0.5);\r\n  gx = gx - tx;\r\n\r\n  vec2 g00 = vec2(gx.x,gy.x);\r\n  vec2 g10 = vec2(gx.y,gy.y);\r\n  vec2 g01 = vec2(gx.z,gy.z);\r\n  vec2 g11 = vec2(gx.w,gy.w);\r\n\r\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\r\n  g00 *= norm.x;\r\n  g01 *= norm.y;\r\n  g10 *= norm.z;\r\n  g11 *= norm.w;\r\n\r\n  float n00 = dot(g00, vec2(fx.x, fy.x));\r\n  float n10 = dot(g10, vec2(fx.y, fy.y));\r\n  float n01 = dot(g01, vec2(fx.z, fy.z));\r\n  float n11 = dot(g11, vec2(fx.w, fy.w));\r\n\r\n  vec2 fade_xy = fade(Pf.xy);\r\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\r\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\r\n  return 2.3 * n_xy;\r\n}\r\n\r\n\r\nfloat rand(float x)\r\n{\r\n    return fract(sin(x) * 4358.5453123);\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\r\n}\r\n\r\nfloat circle(vec2 p, vec2 b, float r)\r\n{\r\n  return length(p-b)-r;\r\n}\r\n\r\nfloat box(vec2 p, vec2 b, float r)\r\n{\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.5 * (\r\n//\t\ttexture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n//\t\ttexture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tconst float speed = 0.4;\r\n\tconst float ySpread = 1.6;\r\n\tconst int numBlocks = 30;\r\n\tconst int numBubbles = 50;\r\n\tfloat pulse = sampleMusic();\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tfloat aspect = iResolution.x / iResolution.y;\r\n\tvec3 baseColor = uv.x > 0.0 ? vec3(0.0,0.3, 0.3) : vec3(0.3, 0.0, 0.3);\r\n\r\n\tvec3 color = 5. * pulse*baseColor*0.5*(0.9-cos(uv.x*8.0));\r\n\tuv.x *= aspect;\r\n\r\n\tfor (int i = 0; i < numBubbles; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.18*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = circle(uv, pos, 0.01 + 0.15 * pulse);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\tfloat block = 0.2*z*smoothstep(0.012, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n        float u_Scale = 9.;\r\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\r\n\t\tcolor += dust*baseColor*(1.+3. * noise) + block*z + shine;\r\n\t}\r\n    baseColor = vec3(0.1, 0.3, 0.0);\r\n    for (int i = 0; i < numBlocks; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.24*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = circle(uv-pos, size, 0.02);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\tfloat block = 0.2*z*smoothstep(0.002, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n        float u_Scale = 9.;\r\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\r\n\t\tcolor += dust*baseColor*(1.+noise) + block*z + shine;\r\n\t}\r\n\tcolor /= 1.5;\r\n\tcolor -= rand(uv)*0.04;\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"XtVSDt",name:"Soap Bubble Music Visualizer #1 by Ruzzyr",shader:"// https://www.shadertoy.com/view/XtVSDt\r\nmat3 rotateYmat(float ang)\r\n{\r\n    return mat3(cos(ang), 0.0, sin(ang),\r\n                0.0, 1.0, 0.0,\r\n                -sin(ang), 0.0, cos(ang));\r\n}\r\nmat3 rotateXmat(float ang)\r\n{\r\n    return mat3(1.0, -0.0, 0.0,\r\n                0.0, cos(ang), -sin(ang),\r\n                0.0, sin(ang), cos(ang));\r\n}\r\n\r\nmat3 rotateZmat(float ang)\r\n{\r\n    return mat3(cos(ang), -sin(ang), 0.0,\r\n                sin(ang), cos(ang), 0.0,\r\n                0.0, 0.0, 1.0);\r\n}\r\n\r\nfloat map( vec3 p, vec3 origin, float s )\r\n{\r\n    vec3 offset = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\r\n\tfloat d = length(p + offset - origin)- s;\r\n\toffset = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n\r\n        float prism2 = length(p + offset*float(i) - origin)- s;\r\n        d = max(d, -prism2);\r\n    }\r\n  \treturn d;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy/iResolution.xy;\r\n    uv = uv*2.0-1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    mat3 rotation = //mat3(1.0);\r\n      rotateXmat(iTime*0.4)*rotateYmat(iTime*0.5);\r\n    vec3 direction = normalize(vec3(uv.x,uv.y, 1.0)*rotation);\r\n\r\n\r\n\r\n\r\n    float t = 0.0;\r\n\tvec3 p;\r\n    vec3 finalColor;\r\n\r\n    vec3 origin = vec3(0.,0.,-4.)*rotation;\r\n    vec3 offset;\r\n    vec3 sphereOrigin = vec3(0., 0., 0.0);\r\n\r\n    vec4 sound = texture (iChannel0,vec2(fragCoord.x/iResolution.x, 0.75));\r\n    float soundColor = texture (iChannel0,vec2(0.5, 0.75)).x;\r\n\r\n    vec3 color = vec3(.5 + sin(uv.x+iTime +soundColor*50.)*.4,.5 +cos(uv.y+iTime + soundColor*5.)*.5,.5);\r\n    for (int k = 0; k <15; k++)\r\n    {\r\n        p = origin + t*direction;\r\n        float d = map(p,sphereOrigin, 2.0);\r\n\r\n        {\r\n            vec3 directionalOffset = -normalize(p)*sound.x*normalize(vec3(uv, 1.0));\r\n            vec3 position = p + directionalOffset;\r\n            float radius = 0.1+float(k)*.5;\r\n            float lineThickness = 0.02 + float(k)*0.01;\r\n            //position.y += position.y*abs(uv.x);\r\n            float distanceFromCenter = length(position);\r\n            float condition = step( distanceFromCenter, radius)\r\n                - step(distanceFromCenter, radius - lineThickness);\r\n            finalColor += color*condition;\r\n        }\r\n\r\n        t += d;\r\n    }\r\n    float fog = 1.0/(1.0+t*t*0.1);\r\n    fragColor = vec4(finalColor+color*vec3(fog), fog);\r\n\r\n}\r\n"},{id:"XsBXWt",name:"Fractal Land by Kali",shader:'// https://www.shadertoy.com/view/XsBXWt\r\n// "Fractal Cartoon" - former "DE edge detection" by Kali\r\n\r\n// There are no lights and no AO, only color by normals and dark edges.\r\n\r\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\r\n\r\n\r\n//#define SHOWONLYEDGES\r\n// #define NYAN\r\n#define WAVES\r\n#define BORDER\r\n\r\n#define RAY_STEPS 150\r\n\r\n#define BRIGHTNESS 1.2\r\n#define GAMMA 1.4\r\n#define SATURATION .65\r\n\r\n\r\n#define detail .001\r\n#define t iTime*.5\r\n\r\n\r\nconst vec3 origin=vec3(-1.,.7,0.);\r\nfloat det=0.0;\r\n\r\n\r\n// 2D rotation function\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\r\n}\r\n\r\n// "Amazing Surface" fractal\r\nvec4 formula(vec4 p) {\r\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\r\n\t\tp.y-=.25;\r\n\t\tp.xy*=rot(radians(35.));\r\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\r\n\treturn p;\r\n}\r\n\r\n// Distance function\r\nfloat de(vec3 pos) {\r\n#ifdef WAVES\r\n\tpos.y+=sin(pos.z-t*6.)*.15; //waves!\r\n#endif\r\n\tfloat hid=0.;\r\n\tvec3 tpos=pos;\r\n\ttpos.z=abs(3.-mod(tpos.z,6.));\r\n\tvec4 p=vec4(tpos,1.);\r\n\tfor (int i=0; i<4; i++) {p=formula(p);}\r\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\r\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\r\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\r\n\tpos.z=abs(.25-mod(pos.z,.5));\r\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\r\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\r\n\tfloat d=min(fr,ro);\r\n\treturn d;\r\n}\r\n\r\n\r\n// Camera path\r\nvec3 path(float ti) {\r\n\tti*=1.5;\r\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\r\n\treturn p;\r\n}\r\n\r\n// Calc normals, and here is edge detection, set to variable "edge"\r\n\r\nfloat edge=0.;\r\nvec3 normal(vec3 p) {\r\n\tvec3 e = vec3(0.0,det*5.,0.0);\r\n\r\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\r\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\r\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\r\n\tfloat d=de(p);\r\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\r\n\tedge=min(1.,pow(edge,.55)*15.);\r\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\r\n}\r\n\r\n\r\n// Used Nyan Cat code by mu6k, with some mods\r\n\r\nvec4 rainbow(vec2 p)\r\n{\r\n\tfloat q = max(p.x,-0.1);\r\n\tfloat s = sin(p.x*7.0+t*70.0)*0.08;\r\n\tp.y+=s;\r\n\tp.y*=1.1;\r\n\r\n\tvec4 c;\r\n\tif (p.x>0.0) c=vec4(0,0,0,0); else\r\n\tif (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\r\n\tif (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\r\n\tif (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\r\n\tif (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\r\n\tif (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\r\n\tif (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\r\n\tif (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\r\n\tif (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\r\n\t\tc=vec4(0,0,0,0);\r\n\tc.a*=.8-min(.8,abs(p.x*.08));\r\n\tc.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\r\n\treturn c;\r\n}\r\n\r\nvec4 nyan(vec2 p)\r\n{\r\n\tvec2 uv = p*vec2(0.4,1.0);\r\n\tfloat ns=3.0;\r\n\tfloat nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\r\n\tfloat ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\r\n\tvec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,.5-uv.y-ny));\r\n\tif (uv.x<-0.3) color.a = 0.0;\r\n\tif (uv.x>0.2) color.a=0.0;\r\n\treturn color;\r\n}\r\n\r\n\r\n// Raymarching and 2D graphics\r\n\r\nvec3 raymarch(in vec3 from, in vec3 dir)\r\n\r\n{\r\n\tedge=0.;\r\n\tvec3 p, norm;\r\n\tfloat d=100.;\r\n\tfloat totdist=0.;\r\n\tfor (int i=0; i<RAY_STEPS; i++) {\r\n\t\tif (d>det && totdist<25.0) {\r\n\t\t\tp=from+totdist*dir;\r\n\t\t\td=de(p);\r\n\t\t\tdet=detail*exp(.13*totdist);\r\n\t\t\ttotdist+=d;\r\n\t\t}\r\n\t}\r\n\tvec3 col=vec3(0.);\r\n\tp-=(det-d)*dir;\r\n\tnorm=normal(p);\r\n#ifdef SHOWONLYEDGES\r\n\tcol=1.-vec3(edge); // show wireframe version\r\n#else\r\n\tcol=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\r\n#endif\r\n\ttotdist=clamp(totdist,0.,26.);\r\n\tdir.y-=.02;\r\n\tfloat sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\r\n\tfloat an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\r\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\r\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\r\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\r\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\r\n\r\n\t// set up background with sky and sun\r\n\tvec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\r\n\t\t backg+=vec3(1.,.9,.1)*s;\r\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\r\n\r\n\tcol=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\r\n\tif (totdist>25.) col=backg; // hit background\r\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\r\n\tcol=mix(vec3(length(col)),col,SATURATION);\r\n#ifdef SHOWONLYEDGES\r\n\tcol=1.-vec3(length(col));\r\n#else\r\n\tcol*=vec3(1.,.9,.85);\r\n#ifdef NYAN\r\n\tdir.yx*=rot(dir.x);\r\n\tvec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\r\n\tvec4 ncat=nyan(ncatpos*5.);\r\n\tvec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\r\n\tif (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\r\n\tif (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\r\n#endif\r\n#endif\r\n\treturn col;\r\n}\r\n\r\n// get camera position\r\nvec3 move(inout vec3 dir) {\r\n\tvec3 go=path(t);\r\n\tvec3 adv=path(t+.7);\r\n\tfloat hd=de(adv);\r\n\tvec3 advec=normalize(adv-go);\r\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\r\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n    an=advec.y*1.7;\r\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n\tan=atan(advec.x,advec.z);\r\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n\treturn go;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\r\n\tvec2 oriuv=uv;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\r\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\r\n\tfloat fov=.9-max(0.,.7-iTime*.3);\r\n\tvec3 dir=normalize(vec3(uv*fov,1.));\r\n\tdir.yz*=rot(mouse.y);\r\n\tdir.xz*=rot(mouse.x);\r\n\tvec3 from=origin+move(dir);\r\n\tvec3 color=raymarch(from,dir);\r\n\t#ifdef BORDER\r\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\r\n\t#endif\r\n\tfragColor = vec4(color,1.);\r\n}\r\n'},{id:"4s33Rj",name:"Music MandelBox Colour by pixelbeast",shader:"// https://www.shadertoy.com/view/4s33Rj\r\n\r\n// Iain Melvin, 2015\r\n// fft distortions of mandlebox 3d, colour\r\n// with help from:\r\n// https://www.shadertoy.com/view/XsB3Rm  // Original Raymarch tutorial (iq)\r\n// https://www.shadertoy.com/view/ldSGRK  // for mandlebox formula (klems)\r\n// Raymarch tutorial: - iq/2013\r\n\r\n\r\nfloat mandel3D(vec3 z,float fft){\r\n  const float scale=3.5; //2.0; // -1.5\r\n  const float r=0.5;\r\n  const float f=1.125;\r\n  vec3 offset = z;\r\n  const int niter = 13;\r\n  float dr = 1.0;\r\n  for (int i=0;i<niter;i++){\r\n\t//fold\r\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\r\n\t//warp\r\n\tfloat l = length(z);\r\n\tif (l<r){\r\n\t  z/=r*r;\r\n\t}else if (l<1.0){\r\n\t  z/=l*l;\r\n\t}\r\n\tz*=scale;\r\n\tdr = dr * abs(scale) + 1.0;\r\n\t// scale by fft\r\n\tfloat fft_scale = 1.0-(fft*0.34);\r\n\tz*=fft_scale;\r\n\t//dr = dr * fft_scale; // I think there is something to do here\r\n\tz+=offset;\r\n  }\r\n  float zr = length(z);\r\n  return zr / abs(dr);\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    float d = length(pos);\r\n    float fft = 0.8*texture(iChannel0, vec2((d/32.0),0.3) )[0];\r\n\treturn vec2(mandel3D(pos*1.5,fft),fft);\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){\r\n\tfloat precis = 0.015;\r\n    float h=precis*2.0;\r\n    float t = 0.0;\r\n    float m = -1.0;\r\n    for( int i=0; i<120; i++ )\r\n    {\r\n        if( abs(h)<precis||t>maxd ) break;\r\n        t += h;\r\n\t    vec2 res = map( ro+rd*t );\r\n        h = res.x; //dist to solid\r\n\t    m = res.y; //fft\r\n    }\r\n    if (t>maxd) { t=-0.5; m=0.0; }\r\n    return vec2( t, m );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ){\r\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n\tvec3 nor = vec3(\r\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n\r\n// iq's smooth hsv to rgb\r\nvec3 hsv2rgb( in vec3 c ){\r\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n\trgb = rgb*rgb*(3.0-2.0*rgb);\r\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 col = vec3(0.0);\r\n    vec2 res = castRay(ro,rd,15.0);\r\n    float t = res.x; // dist to func\r\n\tfloat m = res.y; // fft intense at collision\r\n    vec3 pos = ro + t*rd;\r\n    vec3 nor = calcNormal( pos );\r\n    if (t==-0.5) { nor=vec3(1.0,0.0,0.0); }\r\n\r\n\tcol = hsv2rgb(vec3(m*2.0,1.0,1.0)); // hue sat lum\r\n\r\n    float ao = 1.0;\r\n\r\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\r\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\r\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\r\n\tfloat sh = 1.0;\r\n\r\n\tvec3 brdf = vec3(0.0);\r\n\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\r\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\r\n    brdf += 2.20*dif*vec3(1.00,0.90,0.70);\r\n\r\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\r\n\tfloat spe = sh*pow(pp,16.0);\r\n\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\r\n\r\n\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\r\n\r\n\treturn vec3( clamp(col,0.0,10.0) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy/iResolution.xy;\r\n    vec2 p = -1.0+2.0*q;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n    vec2 mo = iMouse.xy/iResolution.xy;\r\n\r\n\tfloat time = -55.0; //+ iTime;\r\n\r\n    vec3 d = vec3(0.25*mo.x,0.25*mo.y,0.0);\r\n\r\n    d.x += 5.5*(1.0-cos(0.6*iTime));\r\n    d.y += 2.5*(1.0-cos(0.05*iTime));\r\n\r\n\t// camera\r\n\tvec3 ro = vec3( d.x, d.y, 6.0 );\r\n    vec3 ta = vec3( -0.0, -0.0, 0.0 );\r\n\r\n\t// camera tx\r\n\tvec3 cw = normalize( ta-ro );\r\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\r\n\r\n    vec3 col = render( ro, rd );\r\n\tcol = sqrt( col );\r\n\r\n    fragColor=vec4( col, 1.0 );\r\n}\r\n"},{id:"4lyXWW",name:"FFT-IFS by nshelton",shader:"// https://www.shadertoy.com/view/4lyXWW\r\n//#define MAX_ITER 20\r\n#define MAX_ITER 50\r\n\r\nmat3 rotationMatrix(vec3 axis, float angle) {\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    float oc = 1.0 - c;\r\n\r\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\r\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\r\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\n\r\nfloat udBox( vec3 p, vec3 b )\r\n{\r\n  return length(max(abs(p)-b,0.0));\r\n}\r\n\r\nmat3 ir;\r\n\r\nfloat DE(vec3 p)\r\n{\r\n\tvec3 p_o = p;\r\n    float d = 1e10;\r\n\r\n    float s = 1.; //sin(iTime /60.0) / 10.0 + 0.6;\r\n    vec3 t = vec3(0.1 + 0.2 * iMouse.xy/iResolution.xy, 0.1 + 0.1 * sin(iTime/200.));\r\n\r\n    float fftVal = texture(iChannel0,vec2(length(p/5.), 0.2)).x *0.1;\r\n    vec3 dim = vec3( fftVal, 0.9, fftVal);\r\n\r\n    for ( int i = 0; i < 6; i ++)\r\n    {\r\n        p -= t*s;\r\n        p = (ir * (p-t/s));\r\n\r\n     \t//d = min\t(d, udBox(p*s, dim/s) /s);\r\n\r\n \t\tp = abs(p);\r\n\r\n\r\n\r\n        float circleSize = fftVal + 0.03 * (sin(iTime + length(p_o) * 5.) )\r\n            + 0.01;\r\n        d = min(d, length(p - t) - circleSize/s);\r\n        s *= s;\r\n\r\n    }\r\n\r\n\r\n    return d;\r\n}\r\n\r\n\r\nfloat lighting( in vec3 ro, in vec3 rd)\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n\r\n    float k = 12.0;\r\n\r\n    for( int i = 0; i < 2; i++ )\r\n    {\r\n        float h = DE(ro + rd*t);\r\n        if( h<0.001 )\r\n            return 0.0;\r\n\r\n        res = min( res,k * h/t );\r\n        t += h;\r\n    }\r\n    return res;\r\n}\r\n\r\nvec3 gradient(vec3 p) {\r\n\tvec2 e = vec2(0., 0.0001);\r\n\r\n\treturn normalize(\r\n\t\tvec3(\r\n\t\t\tDE(p+e.yxx) - DE(p-e.yxx),\r\n\t\t\tDE(p+e.xyx) - DE(p-e.xyx),\r\n\t\t\tDE(p+e.xxy) - DE(p-e.xxy)\r\n\t\t)\r\n\t);\r\n}\r\n\r\n\r\n\r\n\r\n//https://iquilezles.org/articles/fog\r\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\r\n               in float distance, // camera to point distance\r\n               in vec3  rayDir,   // camera to point vector\r\n               in vec3  sunDir )  // sun light direction\r\n{\r\n    float b = .9 + 20.0 / float(MAX_ITER);\r\n    float fogAmount = 1.0 - exp( -distance*b );\r\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\r\n    vec3  fogColor  = mix( vec3(0.1,0.1,0.0),\r\n                           vec3(1.0,0.9,0.7),\r\n                           pow(sunAmount,8.0) );\r\n    return mix( rgb, fogColor, fogAmount );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    uv -= 0.5;\r\n    float aspect = iResolution.x/iResolution.y;\r\n    uv.x *= aspect;\r\n\r\n    vec3 cam = vec3(0,0, - sin(iTime /32. ) - 2.0);\r\n    vec3 ray = normalize( vec3(uv, 1.0));\r\n\r\n    vec3 color = vec3(0.1, 0.1, 0.2);\r\n    vec3 p;\r\n    float depth = 0.0;\r\n    bool hit = false;\r\n    float iter = 0.0;\r\n\r\n    float fog = 0.0;\r\n    vec3 sun = normalize( vec3(1,1,1));\r\n\r\n    ir = rotationMatrix(normalize(vec3(sin(iTime/50.0),sin(iTime/100.0),sin(iTime/150.0))), 1.5 + iTime/30.0);\r\n\r\n    mat3 mv = rotationMatrix(vec3(0,1,0), iTime/10.0);\r\n\r\n    cam = mv * cam;\r\n    ray = mv * ray;\r\n\r\n    for( int i= 0; i < MAX_ITER; i ++) {\r\n        p = depth * ray + cam;\r\n        float dist = DE(p);\r\n\r\n\r\n        \tdepth += dist * 0.9;\r\n\r\n\r\n        if ( dist < 0.001)\r\n        {\r\n        \thit = true;\r\n            break;\r\n        }\r\n\r\n        iter ++;\r\n    }\r\n    float fakeAO = 1.0 - iter / float(MAX_ITER);\r\n    vec3 n = gradient(p);\r\n\r\n\r\n    if (hit) {\r\n    \tcolor = vec3(fakeAO + dot(-ray,n) / 2.0);\r\n    }\r\n\r\n\r\n\tcolor = applyFog(color, depth, ray, sun) ;\r\n\r\n   //color *= vec3(1.0 - fog);\r\n\r\n    color = pow(color, vec3(0.6));\r\n\r\n\r\n\tfragColor = vec4(color ,1.0);\r\n}\r\n"},{id:"XsfGDS",name:"I/O by movAX13h",shader:"// https://www.shadertoy.com/view/XsfGDS\r\n// I/O fragment shader by movAX13h, August 2013\r\n\r\n#define SHOW_BLOCKS\r\n\r\nfloat rand(float x)\r\n{\r\n    return fract(sin(x) * 4358.5453123);\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\r\n}\r\n\r\nfloat box(vec2 p, vec2 b, float r)\r\n{\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.5 * (\r\n\t\t//texture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n\t\t//texture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tconst float speed = 0.7;\r\n\tconst float ySpread = 1.6;\r\n\tconst int numBlocks = 70;\r\n\r\n\tfloat pulse = sampleMusic();\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tfloat aspect = iResolution.x / iResolution.y;\r\n\tvec3 baseColor = uv.x > 0.0 ? vec3(0.0,0.3, 0.6) : vec3(0.6, 0.0, 0.3);\r\n\r\n\tvec3 color = pulse*baseColor*0.5*(0.9-cos(uv.x*8.0));\r\n\tuv.x *= aspect;\r\n\r\n\tfor (int i = 0; i < numBlocks; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), sign(uv.x)*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.24*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = box(uv-pos, size, 0.01);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\t#ifdef SHOW_BLOCKS\r\n\t\tfloat block = 0.2*z*smoothstep(0.002, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n\t\tcolor += dust*baseColor + block*z + shine;\r\n\t\t#else\r\n\t\tcolor += dust*baseColor;\r\n\t\t#endif\r\n\t}\r\n\r\n\tcolor -= rand(uv)*0.04;\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"MlySWd",name:"Otherworldy by lherm",shader:"// https://www.shadertoy.com/view/MlySWd\r\n#define T iTime\r\n\r\n#define PSD (abs(texture(iChannel0, vec2(.5)).r)*abs(texture(iChannel0, vec2(.5)).r))\r\n\r\n// HG_SDF rotate function\r\n#define r(p, a) {p = cos(a)*p + sin(a)*vec2(p.y,-p.x);}\r\n\r\n// Cabbibo's HSV\r\nvec3 hsv(float h, float s, float v) {return mix( vec3( 1.0 ), clamp( ( abs( fract(h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;}\r\n\r\nvoid mainImage( out vec4 c, in vec2 w )\r\n{\r\n\tvec2 u = (-iResolution.xy+2.*w.xy) / iResolution.y;\r\n    vec3 ro = vec3(u, 1.), rd = normalize(vec3(u, -1.)), p; // Camera and ray dir\r\n    float d = 0., m; // Distance for march\r\n    for (float i = 1.; i > 0.; i-=0.02)\r\n    {\r\n        p = ro + rd * d;\r\n        r(p.zy, T);\r\n        r(p.zx, T);\r\n        m = length(cos(abs(p)+sin(abs(p))+T))-(PSD + .5); // Distance function\r\n        d += m;\r\n        c = vec4(hsv(T, 1.,1.)*i*i, 1.);\r\n        if (m < 0.02) break;\r\n    }\r\n\r\n}\r\n"},{id:"7tGfRD",name:"Converted Plasma Visualizer by MrHAX00",shader:"// https://www.shadertoy.com/view/7tGfRD\r\n#define pi 3.14159\r\nconst vec2 vp = vec2(320.0, 200.0);\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float Freq = texture(iChannel0, vec2(0.)).r;\r\n\tfloat t = iTime * 10.0 + iMouse.x + Freq * 80.;\r\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.xy * (.7 + Freq * .3);\r\n    float Rotate = cos(Freq * 5.) * .2;\r\n    uv *= mat2(cos(Rotate), -sin(Rotate), sin(Rotate), cos(Rotate));\r\n    uv += iTime * .3;\r\n\r\n    vec2 p0 = (uv - 0.5) * vp;\r\n    vec2 hvp = vp * 0.5;\r\n\tvec2 p1d = vec2(cos( t / 98.0),  sin( t / 178.0)) * hvp - p0;\r\n\tvec2 p2d = vec2(sin(-t / 124.0), cos(-t / 104.0)) * hvp - p0;\r\n\tvec2 p3d = vec2(cos(-t / 165.0), cos( t / 45.0))  * hvp - p0;\r\n    float sum = 0.5 + 0.5 * (\r\n\t\tcos(length(p1d) / 40.0) +\r\n\t\tcos(length(p2d) / 30.0) +\r\n\t\tsin(length(p3d) / 35.0) * sin(p3d.x / 20.0) * sin(p3d.y / 15.0)\r\n    );\r\n    vec3 Color = vec3(cos(Freq + uv.x * 3. + iTime + pi * .333333) * .5 + .5, cos(Freq + uv.y * 3. + iTime + pi * .666666) * .5 + .5, -cos(Freq + length(uv) * 3. + iTime) * .5 + .5);\r\n    fragColor = vec4(Color * texture(iChannel0, vec2(fract(sum + iTime), 0.)).r, 1.);\r\n}\r\n"},{id:"3lsXRf",name:"All Night by alyd",shader:'// https://www.shadertoy.com/view/3lsXRf\r\n#define steps 10000.\r\n#define opacity .5\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n        vec4 color;\r\n        vec2 res=iResolution.xy;\r\n        float t = iTime;\r\n        float radialdist;\r\n    \tvec2 st = fragCoord/iResolution.xy;\r\n\r\n\r\n    for (int i=0;i<3;i+=2) {\r\n        vec2 uv,pos=fragCoord.xy/res;\r\n        uv=pos;\r\n        pos-=.5; //centers the image so it\'s radial. pos is relative to screen width so 0.5 is halfway\r\n        pos.x*=res.x/res.y; //scales the aspect ratio\r\n        radialdist=length(pos);\r\n\r\n        //SOUND\r\n        // the pow causes the rings in the center to be thicker.\r\n        // raising radialdist to the power of totalsound creates thinner rings ie more\r\n        // fragmentation at the center when the song gets more intense.\r\n        float totalsound = texture(iChannel0,vec2(0,0)).r;\r\n        float freq_bin = floor(steps*pow(radialdist,2.+1.*totalsound))/steps; //which bin this ring falls into.\r\n        float sound = texture(iChannel0,vec2(1.0-freq_bin,0)).r; //get the sound amplitude at this bin.\r\n        t += 1.*sound; //jump the "time" forward at this bin\r\n\r\n        uv+=pos/radialdist*(sin(t))*sin(radialdist*9.-t*2.);\r\n        color[i]=.01/length(abs(uv-0.5-0.2*(sin(t))));\r\n\r\n        //make a more purple color\r\n        if (i==2){\r\n            color[0]+=.005/length(abs(uv-0.5-0.2*(sin(t))));\r\n            color[2]+=.01/length(abs(uv-0.5-0.2*(sin(t))));\r\n        }\r\n    }\r\n    color[3]=1.0;\r\n    fragColor = color;\r\n}\r\n'},{id:"3sdfDB",name:"Audio Waveform Visualizer v4 by oneshade",shader:"// https://www.shadertoy.com/view/3sdfDB\r\n/*\r\nVersion four of my Audio Waveform Visualizer.\r\nAdded some cool but rather trippy coloring.\r\n*/\r\n\r\n// 0 for frequency mode, 1 for amplitude mode:\r\n#define VIEW_MODE 0\r\n\r\nfloat samplePiecewiseSmooth(in float x, in float res) {\r\n    float xTimesRes = x * res;\r\n\r\n    // Left sample point:\r\n    float x1 = floor(xTimesRes) / res;\r\n    float y1 = texture(iChannel0, vec2(x1, VIEW_MODE)).x;\r\n\r\n    // Right sample point:\r\n    float x2 = ceil(xTimesRes) / res;\r\n    float y2 = texture(iChannel0, vec2(x2, VIEW_MODE)).x;\r\n\r\n    // Prevent small breaks in the line:\r\n    x2 += 0.001;\r\n\r\n    // Fit half of a sine wave between sample points:\r\n    float sine = sin(((x - x1) / (x2 - x1) * 2.0 - 1.0) * 1.5707963267);\r\n    return y1 + (0.5 + 0.5 * sine) * (y2 - y1);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    float curSample = samplePiecewiseSmooth(uv.x, 20.0);\r\n    // How close the pixel is to the wave:\r\n    float smoothError = smoothstep(0.03, 0.0, abs(uv.y - curSample));\r\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    if (smoothError > 0.0) {\r\n        // Mix red and white based on closeness:\r\n        fragColor = vec4(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothError), 1.0);\r\n    }\r\n\r\n    // Multiply by some changing colors:\r\n    fragColor.rgb *= 0.5 + 0.5 * cos(iTime + uv.xyx * vec3(20.0, 1.0, 1.0) + vec3(0.0, 2.0, 4.0));\r\n}\r\n"},{id:"DtfSDH",name:"Basic Audio Visualizer Modified by Spheroidon",shader:"// https://www.shadertoy.com/view/DtfSDH\r\n/* Simple audio visualizer by chronos\r\n// Feel free to use any part of the code and/or improve it further\r\n// Drop a link in the comments! :)\r\n//\r\n// Recommended tracks:\r\n// https://soundcloud.com/kubbi/pathfinder\r\n// https://soundcloud.com/wearecastor/rad\r\n// https://soundcloud.com/jco-de/coronoid-soundtrack\r\n//\r\n*/\r\n\r\n#define WIDTH 1.0\r\n\r\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\r\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\r\n\r\nvec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\r\n    vec3 t = 3.0 * x;\r\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\r\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\r\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\r\n\treturn 0.5 * (\r\n    \tb0 * pow(t, vec3(2.0)) +\r\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) +\r\n    \tb2 * pow(3.0-t,vec3(2.0))\r\n    );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 centered = 2.0 * uv - 1.0;\r\n    centered.x *= iResolution.x / iResolution.y;\r\n\r\n    float dist2 = dot(centered, centered);\r\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\r\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\r\n\r\n    // Color variation functions\r\n    float t = iTime / 100.0;\r\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\r\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\r\n    vec3 spline = B2_spline(spline_args);\r\n\r\n    float f = abs(centered.y);\r\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\r\n    vec3 flame_color = pow(base_color, vec3(3.0));\r\n    vec3 disc_color  = 0.20 * base_color;\r\n    vec3 wave_color  = 0.10 * base_color;\r\n    vec3 flash_color = 0.05 * base_color;\r\n\r\n    float sample1 = audio_freq(iChannel0, abs((uv.x - .5) / WIDTH) + 0.01);\r\n    float sample2 = audio_ampl(iChannel0, clamped_dist);\r\n    float sample3 = audio_ampl(iChannel0, arclength);\r\n\r\n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\r\n    disp_dist *= (1.0 - disp_dist);\r\n\r\n    vec3 color = vec3(0.0);\r\n\r\n    // spline debug\r\n    // vec3 s = smoothstep(-0.01, 0.01, spline-uv.y); color += (1.0-s) * s;\r\n\r\n    float v = abs(uv.y - 0.5);\r\n    color += flame_color * smoothstep(v, v*8.0, sample1);\r\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\r\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\r\n    color += wave_color  * disp_dist;\r\n    color = pow(color, vec3(0.4545));\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"slc3WX",name:"Fork Waves Remi gchipunov 002 by gchipunov",shader:"// https://www.shadertoy.com/view/slc3WX\r\n// oringal createor https://www.shadertoy.com/user/ADOB\r\n// remixer coder: https://www.shadertoy.com/user/gchipunov\r\nfloat squared(float value) { return value * value; }\r\n\r\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\r\n\r\nfloat getWeight(float f) {\r\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = -1.0 + 2.0 * uvTrue;\r\n\r\n\tfloat lineIntensity;\r\n    float glowWidth;\r\n    vec3 color = vec3(0.0);\r\n\r\n\tfor(float i = 0.0; i < 5.0; i++) {\r\n\r\n\t\tuv.y += (0.2 * sin(uv.x + i*7.0 - iTime * 5.6));\r\n        float Y = uv.y + getWeight(squared(i) * 50.0) *\r\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\r\n        lineIntensity = 0.4 + squared(2.6 * abs(mod(uvTrue.x + i / 0.3 + iTime,2.0) - 1.0));\r\n\t\tglowWidth = abs(lineIntensity / (100.0 * Y));\r\n       // float k = i;\r\n        if(i== 0.)\r\n       {\r\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\r\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\r\n                       glowWidth * (2.0 - tan(iTime * 0.19)));\r\n       }\r\n           else   if(i== 1.)\r\n        {\r\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.01)),\r\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n         else   if(i== 2.)\r\n        {\r\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\r\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n        else\r\n        {\r\n \t\tcolor += vec3(glowWidth/2.0 * (2.0 + tan(iTime * 0.13)),\r\n                      glowWidth/2.0 * (2.0 - sin(iTime * 0.23)),\r\n                      glowWidth/2.0 * (2.0 - cos(iTime * 0.19)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n\r\n\t}\r\n\tcolor = color + cos(color)/44.0;\r\n    color = color - tan(iTime * 0.13)/555.0;\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"cdtGW7",name:"barebones music visualizer by rucksack",shader:"// https://www.shadertoy.com/view/cdtGW7\r\nconst float bpm = 120.;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    vec3 col;\r\n\r\n    // Bin x into bars\r\n    float p = .05;\r\n    float frequency = round((uv.x + p/2.)/p)*p;\r\n\r\n    // Find music values\r\n    float amplitude = texture(iChannel0, vec2(frequency, 0.)).r;\r\n    float beat_length = 60./bpm;\r\n\r\n    // Base color depends on UV\r\n    // TODO do the green modulation of 2. based on actual beat of the song maybe\r\n    vec3 base = vec3(1.-uv.x+.1, uv.x, uv.y + .5*(sin(2.*beat_length*3.1415*iTime)+.5));\r\n\r\n    // Draw bar or background\r\n    if (uv.y <= amplitude) {\r\n        col = amplitude * base;\r\n    } else {\r\n        col = .4*uv.y * base + vec3(.01, .1, .05) * sqrt(2.*amplitude);\r\n    }\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"tlcGRH",name:"Inversions Kreis by ShadingAlpaca",shader:"// https://www.shadertoy.com/view/tlcGRH\r\nbool swi = false;\r\nfloat speed = 1.;\r\n\r\nfloat getAnim(float t){\r\n    return tan(speed*t)*1.;\r\n}\r\n\r\nfloat farbe(float t){\r\n    float anim = cos(speed*t);\r\n    if(abs(anim)==1.)\r\n       swi = swi ? false : true;\r\n\r\n    if(swi)\r\n        return (anim<0.?1.:-1.);\r\n    else\r\n        return (anim>=0.?1.:-1.);\r\n}\r\n\r\nvec2 ri = vec2(0.25,0.25);\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = ( fragCoord - .5*iResolution.xy) /iResolution.y;\r\n    float sen = 0.25;\r\n    float fft  = (\r\n        texture(iChannel0, vec2(.0,sen*20.)).x +\r\n        texture(iChannel0, vec2(.3,sen)).x +\r\n        texture(iChannel0, vec2(.6,sen)).x +\r\n        texture(iChannel0, vec2(.9,sen)).x\r\n    );\r\n    float high = (\r\n        texture(iChannel0, vec2(.7,sen)).x +\r\n        texture(iChannel0, vec2(.9,sen*2.)).x\r\n    );\r\n    float low = (\r\n        texture(iChannel0, vec2(.0,sen)).x+\r\n        texture(iChannel0, vec2(.05,sen)).x+\r\n        texture(iChannel0, vec2(.1,sen)).x\r\n    );\r\n\r\n\r\n    //float b = 2.0-length(vec2(uv.x,uv.y));\r\n    float b = texture(iChannel0, vec2(1.2*length(vec2(uv.x,uv.y))\r\n                                      //Kreisverlauf A\r\n                                      //-1.5*(mod(iTime*0.125, 1.)*2. - 1.)\r\n                                      //Kreisverlauf B\r\n                                      -0.2*sin(iTime*0.5)+.1\r\n                                      -0.1*low,sen*1.2)).x;\r\n    float g = length(vec2(uv.x,uv.y))-0.5\r\n        >\r\n        (0.09)*low//*(sin(3.*(atan(uv.x-aspect/2.,uv.y-1./2.)+sin(iTime)))+1.)\r\n        -.2*getAnim(iTime)\r\n        ? 1.+1.5*(farbe(iTime))*b : 1.-1.5*(farbe(iTime))*b;\r\n\r\n    // Time varying pixel color\r\n    float red = (iTheme.r/255.0)*abs(sin(iTime*0.1));\r\n    float green = (iTheme.g/255.0)*abs(sin(iTime*0.11));\r\n    float blue = (iTheme.b/255.0)*abs(sin(iTime*0.12))+0.2;\r\n    vec3 col = vec3(g*red,g*green,g*blue);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"cslSRr",name:"Audio-reactive scene 1st attempt by kishimisu",shader:"// https://www.shadertoy.com/view/cslSRr\r\n/* @kishimisu - 2022\r\n\r\n   First attempt at raymarching scenes\r\n   that react to audio input !\r\n\r\n   I realized that it's really hard\r\n   to isolate the notes in order to\r\n   have different parts of the scene\r\n   react to different sounds without\r\n   manual fine-tuning. I'll try to\r\n   improve on it, any reference on\r\n   this subject is welcome !\r\n*/\r\n\r\n// Set to 1 if you have a really good PC\r\n#define HIGH_PERF 0\r\n\r\n#if HIGH_PERF\r\n    #define iterations           50.\r\n    #define max_dist            500.\r\n// numbers of neighbor lights to check, very expensive so default to 0.\r\n    #define light_neighbors_check 1.\r\n#else\r\n    #define iterations           30.\r\n    #define max_dist            100.\r\n    #define light_neighbors_check 0.\r\n#endif\r\n\r\nfloat lightRep = 12.;    // lights spacing\r\nfloat attenuation = 20.; // light attenuation\r\n\r\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\r\n#define rep(p,r) (mod(p+r/2.,r)-r/2.)\r\n#define rid(p,r) floor((p+r/2.)/r)\r\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\r\n\r\nfloat hash11(float p) {\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 getLight(float d, vec3 color) {\r\n    return max(vec3(0.), color / (1. + pow(abs(d * attenuation), 1.3)) - .001*0.);\r\n}\r\n\r\nfloat getLevel(float x) {\r\n    return texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r;\r\n}\r\n\r\n// The next functions are borrowed from https://www.shadertoy.com/view/7lVBRw\r\n// because they seem to better retrieve the musical aspects from the FFT\r\nfloat getPitch(float freq, int octave){\r\n   return getLevel(pow(2.0, float(octave)) * freq / 12000.0);\r\n}\r\nfloat logX(float x, float a, float c){\r\n   return 1.0 / (exp(-a*(x-c)) + 1.0);\r\n}\r\nfloat logisticAmp(float amp){\r\n   float c = 1.0 - (0.25);\r\n   float a = 20.0 * (1.0 - iMouse.y / iResolution.y);\r\n   a = 20.;\r\n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\r\n}\r\nfloat getAudioIntensityAt(float x) {\r\n    x = abs(fract(x));\r\n    float freq = pow(2., x*3.) * 261.;\r\n    return iChannelTime[0] <= 0. ? hash11(x) : logisticAmp(getPitch(freq, 1));\r\n}\r\n\r\nfloat map(vec3 p, inout vec3 col) {\r\n    //p.z = abs(p.z);\r\n    p.y = abs(p.y) - 13. - getAudioIntensityAt(0.)*1.2;\r\n\r\n    vec2 id = rid(p.xz, 2.);\r\n    p.y += sin( length(sin(id/5.23 - iTime) * cos(id/10.45 + iTime))  ) * 8.;\r\n\r\n    vec3 fp = rep(p, lightRep);\r\n    fp.y = p.y;\r\n\r\n    const float r = light_neighbors_check;\r\n    for (float j = -r; j <= r; j++)\r\n    for (float i = -r; i <= r; i++) {\r\n        vec3 off = vec3(i, 0., j) * lightRep;\r\n        vec3 nid = rid(p - off, lightRep);\r\n        float d = length( fp + off )-1.;\r\n\r\n        // assign more red to lower frequencies, more green to middle and more blue to upper frequencies\r\n        vec3 c = hash33(nid);\r\n        vec3 light = vec3(getAudioIntensityAt(c.r*.33), getAudioIntensityAt(c.g*.33+.33), 4.*getAudioIntensityAt(c.b*.33+.67));\r\n        // make the intensity vary depending on a random frequency (always the same for each light)\r\n        light *= getAudioIntensityAt(c.r+c.b+c.g)+(c.r+c.b+c.g);\r\n        col += getLight(d, light);\r\n    }\r\n\r\n    p.xz = rep(p.xz, 2.);\r\n    return length(p) - 1.;\r\n}\r\n\r\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\r\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\r\n    ro = vec3(iTime*8. -6., 0., 0.);\r\n\r\n    float t = -iTime*.15*0.;\r\n    vec3 f = normalize(vec3(cos(t),0,sin(t)));\r\n    vec3 r = normalize(cross(vec3(0,1,0), f));\r\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\r\n}\r\n\r\nvoid mainImage(out vec4 O, in vec2 F) {\r\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\r\n    vec3 p, ro, rd, col;\r\n\r\n    initRayOriginAndDirection(uv, ro, rd);\r\n\r\n    float t = 0.;\r\n\r\n    for (float i = 0.; i < iterations; i++) {\r\n        p = ro + t*rd;\r\n        //p.yz *= rot(-t*mix(-.01, .01, sin(iTime*.1)*.5+.5));\r\n        t += map(p, col);\r\n        if (t > max_dist) break;\r\n    }\r\n\r\n    col = pow(col, vec3(.45));\r\n    O = vec4(col, 1.0);\r\n}\r\n"},{id:"tdXcRl",name:"Clair De Lune by Agneseion",shader:"// https://www.shadertoy.com/view/tdXcRl\r\n#define PI 3.141592653589793238462643383279502884197169399375105820974\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float contribution = 0.0;\r\n    fragColor = vec4(0.0);\r\n    float phase = .5 * (1.0 + sin(iTime / (2.0 * PI)));\r\n    phase = phase * phase;\r\n    float scale = 1.0;\r\n    for (int i = 0; i < 9; i++)\r\n    {\r\n        vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\r\n\r\n        float offset = phase * uv.x + uv.y;\r\n\r\n        float distanceFromMiddle = length(uv) * .5 * (1.0 + sin(offset + iTime / scale * 0.25));\r\n\r\n        // Time varying pixel color\r\n        vec4 music = texture(iChannel0, vec2(distanceFromMiddle));\r\n        vec3 col = length(music.rgb) * cos(scale*iTime/10.0+vec3(0,2,4));\r\n\r\n        // Output to screen\r\n        float colourfulness = clamp(length(col) + phase, 0.0, 1.0);\r\n        float colourlessness = 1.0 - colourfulness;\r\n\r\n        float localContribution = scale / (1.0 + pow(distanceFromMiddle, -phase));\r\n        vec3 colourVector = clamp(col, .5 - scale, .5 + scale);\r\n        vec3 colourlessVector = vec3(length(colourVector));\r\n\r\n        fragColor += localContribution*vec4(colourfulness * colourVector + colourlessness * colourlessVector, 1.0);\r\n        contribution += localContribution;\r\n        scale /= 2.0;\r\n    }\r\n    fragColor /= contribution;\r\n}\r\n"},{id:"dd2Xzm",name:"PHONK by Poisson",shader:"// https://www.shadertoy.com/view/dd2Xzm\r\n// press pause and play if there's no music\r\n\r\n// music frequency\r\nfloat freq;\r\n\r\n// hash vec2 to float\r\nfloat hash21(vec2 p) {\r\n    p = fract(p*vec2(452.127,932.618));\r\n    p += dot(p, p+123.23);\r\n    return fract(p.x*p.y);\r\n}\r\n\r\n// noise function by me\r\nfloat noise(vec2 p) {\r\n    vec2 q = floor(p);\r\n    vec2 f = fract(p);\r\n    return mix(mix(hash21(q+vec2(0,0)),hash21(q+vec2(1,0)),f.x),\r\n               mix(hash21(q+vec2(0,1)),hash21(q+vec2(1,1)),f.x),f.y);\r\n}\r\n\r\n// fractal noise\r\nfloat fbm(vec2 p) {\r\n    float f = 0.;\r\n    f +=     .5*noise(p);\r\n    f +=    .25*noise(p*2.);\r\n    f +=   .125*noise(p*4.);\r\n    f +=  .0625*noise(p*8.);\r\n    f += .03125*noise(p*16.);\r\n    return f;\r\n}\r\n\r\n// background noise\r\nfloat func(vec2 p) {\r\n    return fbm(vec2(sin(iTime*.8),cos(iTime*.8))+p*fbm(p+.2*iTime)+noise(p+noise(p+noise(p))));\r\n}\r\n\r\n// rendering function\r\nvec3 render(vec2 p) {\r\n    p *= .55+.2*freq; // bounce\r\n\r\n    // background\r\n    vec3 colA = vec3(0,.18,0);\r\n    vec3 colB = vec3(1.15,.75,.83);\r\n    float k = pow(func(9.*p),1.2);\r\n    vec3 col = smoothstep(colA,colB,vec3(k));\r\n\r\n    // ball\r\n    float x = atan(p.x,p.y); // polar x value\r\n    // frequencies\r\n    float f = texture(iChannel0, vec2(x*.018+.4,.25)).r;\r\n    // radius\r\n    float r = .2+4.*min(pow(f,8.),.1)*clamp(p.y+.06,0.,1.);\r\n    // hollow circle\r\n    float m = abs(length(p)-r)-.02;\r\n\r\n    // draw the ball\r\n    float b = fwidth(m); // blur value\r\n    col = mix(col, vec3(1), smoothstep(b,-b,m));\r\n\r\n    return clamp(col,0.,1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // pixel coordinates centered at the origin\r\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\r\n    // normalized pixel coordinates\r\n    vec2 q = fragCoord/iResolution.xy;\r\n\r\n    // music frequency\r\n    freq = texture(iChannel0, vec2(.01,.25)).r;\r\n\r\n    // render with chromatic aberration\r\n    vec2 off = (q-.5) * .03*pow(freq,4.); // CA offset\r\n    vec3 col = vec3(render(p+off).r,\r\n                    render(p).g,\r\n                    render(p-off).b);\r\n\r\n    col += .5*col*pow(freq,8.); // flash\r\n    // vignette\r\n    col *= .5+.5*pow(64.*q.x*q.y*(1.-q.x)*(1.-q.y),.1);\r\n\r\n    col *= 1.-exp(-iTime*2.); // fade\r\n\r\n    // output\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"fsKyzd",name:"purple sound visualizer by TonyIlersich",shader:"// https://www.shadertoy.com/view/fsKyzd\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float majorAxis = max(iResolution.x, iResolution.y);\r\n    vec2 uv = fragCoord/majorAxis;\r\n    vec2 center = iResolution.xy/2.0/majorAxis;\r\n    vec2 rel = uv-center;\r\n    vec2 disp = abs(rel) * 1.2 + length(rel) * .8;\r\n    float d = max(disp.x,disp.y);\r\n    d += 0.01 * d * cos(12.0 * atan(rel.y, rel.x));\r\n    int n = int(512.0 * pow(d*.9+.1, 2.0));\r\n\r\n    float fft = texelFetch(iChannel0, ivec2(n, 0), 0).x;\r\n\r\n    vec3 col = vec3(\r\n        pow(fft*1.2, 11.0 + 2.0*(1.0-d)),\r\n        pow(fft*1.1, 12.0 + 2.0*(1.0-d)),\r\n        pow(fft*1.3, 12.0 + 2.0*(1.0-d)));\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"4t2cR1",name:"♫ Sailing Beyond - Hyper Tunnel by patu",shader:'// https://www.shadertoy.com/view/4t2cR1\r\n/*\r\n\r\n    Hyper Tunnel from "Sailing Beyond" (demoscene producion)\r\n\r\n    https://www.youtube.com/watch?v=oITx9xMrAcM&\r\n\thttps://www.pouet.net/prod.php?which=77899\r\n\r\n\r\n*/\r\n\r\n\r\n/*\r\n\thttp://bit.ly/shadertoy-plugin\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n#pragma optimize(off)\r\n\r\n\r\n\r\n\r\n\r\n#define getNormal getNormalHex\r\n\r\n#define FAR 1e3\r\n#define INFINITY 1e32\r\n\r\n#define T iTime\r\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\r\n#define FOV 70.0\r\n#define FOG .06\r\n\r\n#define PI 3.14159265\r\n#define TAU (2*PI)\r\n#define PHI (1.618033988749895)\r\n\r\nfloat vol = 0.;\r\n\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\r\n\tvec3 u = 1.-(--f)*f*f*f*-f;\r\n\r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );\r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) );\r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n\r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );\r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n\r\n    return max(mix(v1,v2,u.z),0.);\r\n}\r\n\r\nfloat fbm(vec3 x)\r\n{\r\n    float r = 0.0;\r\n    float w = 1.0, s = 1.0;\r\n    for (int i=0; i<4; i++)\r\n    {\r\n        w *= 0.25;\r\n        s *= 3.;\r\n        r += w * noise_3(s * x);\r\n    }\r\n    return r;\r\n}\r\n\r\nfloat yC(float x) {\r\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ fbm(vec3(x * .1, 0., 0.) * 55.4);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nstruct geometry {\r\n    float dist;\r\n    vec3 hit;\r\n    int iterations;\r\n};\r\n\r\n\r\n// Cylinder with infinite height\r\nfloat fCylinderInf(vec3 p, float r) {\r\n\treturn length(p.xz) - r;\r\n}\r\n\r\ngeometry map(vec3 p) {\r\n    p.x -= yC(p.y * .1) * 3.;\r\n    p.z += yC(p.y * .01) * 4.;\r\n\r\n    float n = pow(abs(fbm(p * .06 )) * 12., 1.3);\r\n    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;\r\n\r\n    geometry obj;\r\n\r\n    obj.dist = max(0., -fCylinderInf(p, s + 18. -n));\r\n\r\n    p.x -= sin(p.y * .02) * 34. + cos(p.z * 0.01) * 62.;\r\n\r\n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nfloat t_min = 10.0;\r\nfloat t_max = FAR;\r\nconst int MAX_ITERATIONS = 100;\r\n\r\ngeometry trace(vec3 o, vec3 d) {\r\n    float omega = 1.3;\r\n    float t = t_min;\r\n    float candidate_error = INFINITY;\r\n    float candidate_t = t_min;\r\n    float previousRadius = 0.;\r\n    float stepLength = 0.;\r\n    float pixelRadius = 1./ 1000.;\r\n\r\n    geometry mp = map(o);\r\n\r\n    float functionSign = mp.dist < 0. ? -1. : +1.;\r\n    float minDist = FAR;\r\n\r\n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\r\n\r\n        mp = map(d * t + o);\r\n\t\tmp.iterations = i;\r\n\r\n        float signedRadius = functionSign * mp.dist;\r\n        float radius = abs(signedRadius);\r\n        bool sorFail = omega > 1. &&\r\n        \t(radius + previousRadius) < stepLength;\r\n\r\n        if (sorFail) {\r\n            stepLength -= omega * stepLength;\r\n            omega = 1.;\r\n        } else {\r\n        \tstepLength = signedRadius * omega;\r\n        }\r\n        previousRadius = radius;\r\n        float error = radius / t;\r\n\r\n        if (!sorFail && error < candidate_error) {\r\n            candidate_t = t;\r\n            candidate_error = error;\r\n        }\r\n\r\n        if (!sorFail && error < pixelRadius || t > t_max) break;\r\n\r\n        t += stepLength * .5; // ;(\r\n   \t}\r\n\r\n    mp.dist = candidate_t;\r\n\r\n    if (\r\n        (t > t_max || candidate_error > pixelRadius)\r\n    \t) mp.dist = INFINITY;\r\n\r\n\r\n    return mp;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n    vec2 ouv = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = ouv - .5;\r\n\r\n    uv *= tan(radians (FOV) / 2.0) * 4.;\r\n\r\n    vec3\r\n        vuv = normalize(vec3(cos(T), sin(T * .11), sin(T * .41))), // up\r\n    \tro = vec3(0., 30. + iTime * 100., -.1);\r\n\r\n    ro.x += yC(ro.y * .1) * 3.;\r\n    ro.z -= yC(ro.y * .01) * 4.;\r\n\r\n    vec3 vrp =  vec3(0., 50. + iTime * 100., 2.);\r\n\r\n    vrp.x += yC(vrp.y * .1) * 3.;\r\n    vrp.z -= yC(vrp.y * .01) * 4.;\r\n\r\n    vec3\r\n\t\tvpn = normalize(vrp - ro),\r\n    \tu = normalize(cross(vuv, vpn)),\r\n    \tv = cross(vpn, u),\r\n    \tvcv = (ro + vpn),\r\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\r\n    \trd = normalize(scrCoord - ro),\r\n        oro = ro;\r\n\r\n    vec3 sceneColor = vec3(0.);\r\n\r\n    geometry tr = trace(ro, rd);\r\n\r\n    tr.hit = ro + rd * tr.dist;\r\n\r\n    vec3 col = vec3(1., 0.5, .4) * fbm(tr.hit.xzy * .01) * 20.;\r\n    col.b *= fbm(tr.hit * .01) * 10.;\r\n\r\n    sceneColor += min(.8, float(tr.iterations) / 90.) * col + col * .03;\r\n    sceneColor *= 1. + .9 * (abs(fbm(tr.hit * .002 + 3.) * 10.) * (fbm(vec3(0.,0.,iTime * .05) * 2.)) * 1.);\r\n    sceneColor = pow(sceneColor, vec3(1.)) * (iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(128, 0), 0).r * min(1., mt * .1) : 0.6);\r\n\r\n    vec3 steamColor1 = vec3(.0, .4, .5);\r\n\tvec3 rro = oro;\r\n\r\n    ro = tr.hit;\r\n\r\n    float distC = tr.dist, f = 0., st = .9;\r\n\r\n    for (float i = 0.; i < 24.; i++) {\r\n        rro = ro - rd * distC;\r\n        f += fbm(rro * vec3(.1, .1, .1) * .3) * .1;\r\n        distC -= 3.;\r\n        if (distC < 3.) break;\r\n    }\r\n\r\n    steamColor1 *= iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(32, 0), 0).r : 1.;\r\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.) * 4.;\r\n\r\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0);\r\n    fragColor = pow(abs(fragColor / tr.dist * 130.), vec4(.8));\r\n\r\n}\r\n'},{id:"WdKyzd",name:"swirly rainbow sound visualizer by TonyIlersich",shader:"// https://www.shadertoy.com/view/WdKyzd\r\n#define tao 6.283185307179586476925286766559\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\r\n    vec2 ctr = iResolution.xy/2.0/max(iResolution.x, iResolution.y);\r\n    vec2 disp = uv - ctr;\r\n\r\n    vec2 polar = vec2(length(disp)*2.0, atan(disp.y, disp.x)/tao+.5);\r\n\r\n    vec2 wave = texture(iChannel0, vec2(polar.x*2.0, 1)).xy;\r\n\r\n    float smallAmp = .1*polar.x*pow(wave.x, 5.0);\r\n    float bigAmp = .6*pow(polar.x, .9)*pow(wave.x, 7.0);\r\n\r\n    float targetF =\r\n        (1.0-abs(smallAmp+bigAmp))*polar.x\r\n        -smallAmp*sin(iTime+polar.y*tao*24.0)\r\n        -bigAmp*sin((.125+polar.y)*tao*2.0);\r\n    float f = pow(targetF, 2.5);\r\n\r\n    vec2 freq = texture(iChannel0, vec2(f, 0)).xy;\r\n\r\n    vec3 col = 0.5 + 0.5*cos(\r\n        .4*iTime\r\n        -tao*(polar.x*sqrt(1.0+wave.x)+polar.y)\r\n        +vec3(tao*.0,tao*.33,tao*.67)\r\n   \t);\r\n\r\n    col *= vec3(.9, .9, 1.0);\r\n\r\n    col *= pow(freq.x, 4.0);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"7ldczN",name:"Tangerine Dream Visualizer 2 by gurudevbk",shader:"// https://www.shadertoy.com/view/7ldczN\r\n#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\r\n\r\nfloat avgBassFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.0; pos < 0.1; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nfloat avgMedFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.1; pos < 0.6; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nfloat avgTopFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.6; pos < 1.0; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n\r\n\r\n    float aspect = iResolution.y/iResolution.x; //aspect ratio of viewport\r\n    float value; //var\r\n\tvec2 uv = fragCoord.xy / iResolution.x; //vec ratio of fragment coordinate to width of viewport\r\n\r\n    float bassFreq = pow(avgBassFreq(), 0.85);\r\n    float medFreq = pow(avgMedFreq(), 0.85);\r\n    float topFreq = pow(avgTopFreq(), 0.85);\r\n\r\n    float rot = radians(45.0); // radians(45.0*sin(iTime)); //radians(45.0)\r\n    float rot2 = radians(45.0*sin(iTime)); // radians(45.0*sin(iTime)); //radians(45.0)\r\n\r\n    uv -= vec2(0.5, 0.5*aspect); //transform\r\n\r\n\r\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n   \tuv  = m * uv;\r\n    uv *= vec2(1., 1.7*aspect);\r\n    uv.y+=0.01*(2.0-aspect);\r\n    vec2 pos = 200.0*uv;\r\n    vec2 rep = fract(-0.9*tan(rot2)+cos(rot2/2.0)*pos);\r\n    float dist = min(min(rep.x, rep.x), min(rep.y, 1.0-rep.y));\r\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(1.0) );\r\n\r\n    float edge = 4.*sin(squareDist)*0.5+0.5;\r\n\r\n    edge = ((iTime+bassFreq+medFreq)/20.-squareDist*((iTime*medFreq+topFreq)/50000.))*.4;\r\n    edge = (medFreq)/(topFreq)*fract(edge*squareDist);\r\n    //value = medFreq*abs(dist-bassFreq);\r\n    //value = pow(dist, 2.0);\r\n    value = fract (dist*2.0);\r\n    value = mix(value, 1.0-value, step(1.0, edge));\r\n    //value *= 1.0-0.5*edge;\r\n    edge = pow(abs(1.0-edge), 2.0);\r\n\r\n    edge = .5*(medFreq)-abs(1.0-edge)+topFreq;\r\n    //value = smoothstep( edge-0.25, edge, 0.55*value);\r\n\r\n\r\n    value += squareDist*.1;\r\n    //fragColor = vec4(value);\r\n    fragColor = mix(vec4(1.0,edge/2.,value/4.,1.0)*(cos(rot2)/4.0),vec4(0.5,0.75,1.0,1.), edge);\r\n    fragColor.a = 0.25*clamp(edge, 0.0, 1.0);\r\n    fragColor.b += sin(iTime+medFreq)*.5+.5;\r\n    fragColor.r /= .8*bassFreq+sin(iTime+medFreq)*.1+.2;\r\n    fragColor.g += topFreq*.1;\r\n}\r\n"},{id:"NdSGW3",name:"ViolentEyeSimulator314 by Domain314",shader:"// https://www.shadertoy.com/view/NdSGW3\r\nfloat red (vec2 gv, float fft){\r\n    float d = distance(gv, vec2(0.5));\r\n    return smoothstep(0.15, fft, d);\r\n}\r\n\r\nfloat blue (vec2 gv, float fft){\r\n    float d = distance(gv, vec2(0.5));\r\n    return smoothstep(0., fft/2., d);\r\n}\r\n\r\nfloat green(vec2 gv, float fft){\r\n    return smoothstep(0.75, 0.55, gv.y)*(fft-0.1);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\r\n    uv += vec2(0., 0.5);\r\n    vec3 col = vec3(0.);\r\n    vec2 gv = fract(uv);\r\n\r\n    int tx = int(gv.y*512.);\r\n    float fft = texelFetch(iChannel0, ivec2(tx, 0), 0).x;\r\n    float fft2 = texelFetch(iChannel0, ivec2(tx, 1), 0).x;\r\n\r\n    float r = red(gv, fft);\r\n    float b = blue(gv, fft2);\r\n    float g = green(gv, fft2);\r\n\r\n    col.r += r;\r\n    col.b += 1.-b*1.5;\r\n    col.g += 1.-b*1.8;\r\n    col.g += g;\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"Wll3Df",name:"Simple rainbow by avin",shader:"// https://www.shadertoy.com/view/Wll3Df\r\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\r\n#define BLACK_COL vec3(32,43,51)/255.\r\n\r\nfloat line(vec2 p,vec2 size){\r\n\tfloat mask =\r\n        smoothstep(size.x, size.x-.1, abs(p.x)) *\r\n        smoothstep(size.y, size.y-.1, abs(p.y));\r\n\r\n    return smoothstep(.45, .5, mask);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.y;\r\n\r\n    vec2 aRatio = vec2(30., 1.);\r\n    vec2 guv = uv * aRatio;\r\n    vec2 id = floor(guv);\r\n    guv = fract(guv);\r\n    guv -= .5;\r\n\r\n    vec2 muzUV = floor(uv * aRatio) / aRatio;\r\n    vec4 muz = texture(iChannel0, muzUV * .5);\r\n    muz.x +=  (sin(iTime + id.x*.25)*.5+.5)*.25;\r\n    vec2 size = vec2(0.75, muz.x*.3 + .05);\r\n\r\n    vec2 sf = aRatio * .025;\r\n    float mask =\r\n        smoothstep(size.x, size.x-sf.x, abs(guv.x)) *\r\n        smoothstep(size.y, size.y-sf.y, abs(guv.y));\r\n\r\n    float m = smoothstep(.25, .5, mask);\r\n\r\n    vec3 col = hue(fract(size.y*5. + iTime*.05)).rgb;\r\n\r\n    col = mix(BLACK_COL, col, m);\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"ddy3DD",name:"🎶 Tequilla Rainbow by wj",shader:'// https://www.shadertoy.com/view/ddy3DD\r\n// "Tequilla Rainbow" by wj\r\n// based on avin\'s "Rainbow soundviz": https://www.shadertoy.com/view/ttfGzH\r\n// license: CC-BY-NC-SA\r\n\r\n\r\n#define PI 3.1415926\r\n#define PI2 6.2831852\r\n\r\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\r\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\r\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\r\n}\r\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\r\n//  Macro version of above to enable compile-time constants\r\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\r\n\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n {\r\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\r\n\r\n    float CIRCLES = 9.;\r\n    float cS = .93275;\r\n\r\n    float sm = 1.0 / iResolution.y * 25.0;\r\n    float ps = 1.0 / iResolution.y * sqrt(iResolution.y) * 1.9;\r\n\r\n    float d = length(uv);\r\n\r\n    float a = atan(uv.y, uv.x);\r\n    a = a < 0.0 ? PI + (PI - abs(a)) : a;\r\n\r\n    float lPos = a /PI2;\r\n\r\n    float m = 0.0;\r\n    float partSize = 1.0 / CIRCLES * 1.05;\r\n    vec3 col;\r\n\r\n    float t= iTime;\r\n\r\n    for(float i = 9.; i > 1.0; i -= 1.0) {\r\n\r\n        float ilPos = fract(lPos + i*0.1 + t * 0.1);\r\n        float cPos = partSize * i + ilPos * partSize;\r\n        float invPos = partSize * (i + 1.0) - ilPos * partSize;\r\n        float nzF = (1.0 - ilPos);\r\n        float mP0 = texture(iChannel0, vec2(partSize * i, 0.0)).x * 0.8;\r\n        float mP = texture(iChannel0, vec2(cPos, 0.0)).x * 0.8;\r\n        float mPInv = texture(iChannel0, vec2(invPos, 0.0)).x * 0.8;\r\n\r\n        mP = (mP + mPInv) * .5 ;\r\n\r\n        float rDiff = i*(1.0 / CIRCLES * .8);\r\n        float r = mP * (1.0 / CIRCLES * 5.0) - rDiff;\r\n\r\n        float subm = smoothstep(cS - ps + r, cS - ps + sm + r, d) * smoothstep(cS + r, cS - sm + r, d);\r\n\r\n        if (subm > 0.0) {\r\n//            col += HSV2RGB(vec3(i / CIRCLES * 0.5 + t * 0.05 + mP0 * 0.184, 0.95, .0025))*400.;   // cycle hue\r\n            col += HSV2RGB(vec3(i / CIRCLES * 0.5 + 14.4*0.05 + mP0 * 0.184, 0.95, .0025))*400.;\r\n            m += subm;\r\n        }\r\n    }\r\n\r\n    m = clamp(m, 0.0, 1.0);\r\n\r\n    float r =  (sin(t * 0.5) * 0.5 + 0.5);\r\n    float b = (cos(t * 0.5) * 0.5 + 0.5);\r\n    vec3 backCol = vec3(r, 0.0, b) * length(uv * 0.75) * 0.5;\r\n\r\n    col = mix(backCol, col, m);\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n'},{id:"WtV3Dd",name:"Trippy Visualizer by MinimilisticBits",shader:"// https://www.shadertoy.com/view/WtV3Dd\r\n//const float pi = 3.14159265358979323846264338327950288419716939937510; //just pi\r\nconst float ni = 3.0778979877877658472;\r\n\r\n/*vec2 rot(vec2 a, float c){\r\nfloat g = c*pi/180.0;\r\nvec2 b = vec2(cos(g),sin(g));\r\nreturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\r\n}*/\r\n\r\nvec2 rot(vec2 a, float c){ //mine\r\n//acos 1 to -1 = 0 to pi\r\nfloat p = length(a);\r\na = normalize(a);\r\nfloat ang_x = atan(a.y,a.x);\r\nang_x +=  c*ni/180.0;\r\nreturn vec2(p*cos(ang_x), p*sin(ang_x));\r\n}\r\n\r\n\r\nfloat box(vec3 p, vec3 s){//mine\r\nvec3 a = abs(p)-s;\r\nreturn max(max(a.x, a.y),a.z);\r\n}\r\n\r\n/*\r\nvec3 r(vec3 p, vec3 c){//not originally thought by me\r\nreturn mod(p,c)-0.5*c;\r\n}\r\n*/\r\n\r\nvec3 r(vec3 p, vec3 c){\r\nreturn ((p/c - floor(p/c))*c)-0.5*c;\r\n}\r\n\r\n\r\nfloat dis(vec3 p){\r\nreturn min(length(mod(p,8.0)-4.0)-1.3,\r\n          box(r(vec3(0.0, -4.0, 0.0)-p, vec3(20.0,20.0,3.0)), vec3(40.0,0.5,0.5))\r\n          );\r\n}\r\n\r\nbool trac(out vec3 p, vec3 d, out float dd){\r\n    for(int i = 0; i < 40; i++){\r\n        dd = dis(p);\r\n        if(dd < 0.01){return true;}\r\n        p+=d*dd;\r\n    }\r\n    return false;\r\n}\r\n\r\n/*\r\nvec3 norm(vec3 p){//not originally by me\r\nvec2 k = vec2(0.1,0.0);\r\nreturn normalize(\r\nvec3(\r\ndis(p+k.xyy)-dis(p-k.xyy),\r\ndis(p+k.yxy)-dis(p-k.yxy),\r\ndis(p+k.yyx)-dis(p-k.yyx)\r\n));\r\n}\r\n*/\r\n\r\nvec3 norm(vec3 p, float dist){\r\n    return normalize(vec3(dist-dis(vec3(p.x-0.1,p.yz)),dist-dis(vec3(p.x,p.y-0.1,p.z)),\r\n                          dist-dis(vec3(p.xy,p.z-0.1))));\r\n}\r\n\r\n\r\n\r\nvec3 shadow(vec3 p, vec3 lig){\r\n    vec3 d = normalize(lig - p);\r\n    float dist,lgg;\r\n    for(int i = 0; i < 40; i++){\r\n     lgg = length(lig-p)-1.3;\r\n     dist = min(lgg, dis(p));\r\n     if(dist < 0.01)break;\r\n     p+=d*dist;\r\n    }\r\n    if(dist < 0.01 && dist == lgg){\r\n    return vec3(1.0);\r\n    }\r\n\r\n    vec3 n = norm(p,dist);\r\n    float ang = 1.0-dot(-d,n);\r\n    vec3 c = vec3((cos(iTime-ang*2.0)+1.0)*0.5, (sin(iTime+ang*12.0)+1.0)*0.5, 0.5);\r\n    return c*ang;\r\n}\r\n\r\nvec3 volumetrics(vec3 prevp, vec3 p, vec3 lig){\r\n    const int iter = 7;\r\n    vec3 dp = (p-prevp)/float(iter);\r\n\r\n    vec3 vcol;\r\n\r\n    for(int i = 0; i < iter; i++){\r\n    vcol += shadow(prevp+dp*float(i+1), lig);\r\n    }\r\n\r\n    return vcol/float(iter);\r\n}\r\n\r\nfloat rough(float a, float c){\r\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0) - a ,2.0))/(ni*a);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float sp = texture(iChannel0, vec2(0.0 / 512.0, 0.0)).x;\r\n\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    uv -= vec2(0.5);\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    uv *= vec2(2.0+sp*2.0);\r\n\r\n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\r\n    vec2 mouse = iMouse.xy / iResolution.xy;\r\n    mouse = mouse * 2.0 - 1.0;\r\n\r\n    d = abs(-vec3(rot(d.xz, iTime*6.0),d.y));\r\n    d.yz = rot(d.yz, cos(iTime*0.4 - sp*1.6)*90.0);\r\n    d.xy = rot(d.xy, sin(iTime*0.2 + sp*1.3)*180.0);\r\n    vec3 p = vec3(0.0);\r\n    vec3 prevp = p;\r\n    vec3 col = vec3(0.0);\r\n    vec3 lig = vec3(sin(iTime)*5.0,10.0,2.0+cos(iTime)*6.0);\r\n    float dd;\r\n    if(trac(p,d,dd)){\r\n        vec3 n = norm(p,dd);\r\n        vec3 light = normalize(lig-p);\r\n\r\n        col = vec3(0.6)*max(dot(n,light),0.1);\r\n        col+= rough(0.4, dot(reflect(d,n),light));\r\n        col*=shadow(p-d*0.1, lig);\r\n    }\r\n\r\n    col += volumetrics(prevp,p, lig)*0.7;\r\n    //col = mix(volumetrics(prevp,p, lig), col, 0.5);\r\n\r\n    float dist = abs(length(vec2(0.5) - fragCoord/iResolution.xy));\r\n    col-= dist*dist*0.6;\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"Mst3Wl",name:"Music visualiser by Ruzzyr",shader:"// https://www.shadertoy.com/view/Mst3Wl\r\nmat3 rotateYmat(float ang)\r\n{\r\n    return mat3(cos(ang), 0.0, sin(ang),\r\n                0.0, 1.0, 0.0,\r\n                -sin(ang), 0.0, cos(ang));\r\n}\r\nmat3 rotateXmat(float ang)\r\n{\r\n    return mat3(1.0, -0.0, 0.0,\r\n                0.0, cos(ang), -sin(ang),\r\n                0.0, sin(ang), cos(ang));\r\n}\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    vec3 o = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\r\n\tfloat d = length(p + o)- s;\r\n\to = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        float prism2 = length(p + o*float(i))- s;\r\n        d = max(d, -prism2);\r\n    }\r\n  \treturn d;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy/iResolution.xy;\r\n    uv = uv*2.0-1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    vec3 dir = normalize(vec3(uv, 1.0))*rotateYmat(iTime)*rotateXmat(iTime);\r\n\r\n    float t = 0.0;\r\n\tvec3 p;\r\n    vec3 fc;\r\n        vec3 o = vec3(0.,0.,-4.)*rotateYmat(iTime)*rotateXmat(iTime);\r\n        vec4 s = texture (iChannel0,vec2(fragCoord.x/iResolution.x-0.01, 0.75));\r\n\t\tvec3 cl = vec3(.5 + sin(uv.x+iTime +s.x*5.)*.4,.5 +cos(uv.y+iTime + s.x*5.)*.5,.5);\r\n        for (int k = 0; k <15; k++)\r\n        {\r\n            p = o + t*dir;\r\n            float d = sdSphere(p, 2.0);\r\n\r\n            {\r\n                vec3 position = p;\r\n                float radius = 0.1+float(k)*0.5+clamp(s.x, 0.0, 1.0)*1.;\r\n                float lineThickness = 0.02 + float(k)*0.01;\r\n\r\n                vec3 o = vec3(sin(position.x*10. + iTime*0.9),sin(position.y*10. + iTime ),cos(position.z*10. + iTime*1.9))*0.5;\r\n                float condition = step(length(position + o) , radius)\r\n                                      - step(length(position + o), radius - lineThickness);\r\n                fc += cl*condition;\r\n            }\r\n\r\n            t += d;\r\n        }\r\n    fragColor = min(vec4(fc+cl*vec3(1.0/(1.0+t*t*0.1)), 1.0), vec4(1.0));\r\n}\r\n"},{id:"fssXD4",name:"Audio pulsar by atutahi",shader:"// https://www.shadertoy.com/view/fssXD4\r\nfloat Catmull_Rom(float x, float v0,float v1, float v2,float v3)\r\n{\r\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\r\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\r\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\r\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\r\n}\r\n\r\nfloat sampleFFT(float fftCoord)\r\n{\r\n    float atten = smoothstep(0.0, 0.05, 1.0 - fftCoord) * smoothstep(0.0, 0.05, fftCoord);\r\n    return atten * texture( iChannel0, vec2(fftCoord,0.25) ).x;\r\n}\r\n\r\nvec2 opRep( in vec2 p, in vec2 c)\r\n{\r\n    return mod(p+0.5*c,c)-0.5*c;\r\n}\r\n\r\n#define PI 3.14159\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    // create pixel coordinates\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    uv = uv * 2. - 1.;\r\n    uv.x /= iResolution.y / iResolution.x;\r\n    uv += 0.3 * vec2(sin(-iTime * 0.3), cos(iTime * 0.5));\r\n    // second texture row is the sound wave\r\n\r\n\tfloat wave = texture( iChannel0, vec2(0.5,0.75) ).x;\r\n\r\n    float angle = atan(uv.y, uv.x);  // atan2\r\n    vec2 range = vec2(-PI, PI);  // The range of atan2 is [-pi / 1; pi / 1]\r\n    float theta = smoothstep(range[0], range[1], angle);  // Normalize the range of atan to [0;1]\r\n    theta = mod(theta + iTime * 0.05, 1.0);\r\n\r\n    float ro = length(uv);\r\n    ro *= 3.0 - 0.2 * clamp(0.0, 1.0, (pow(wave, 0.4)));\r\n    uv = vec2(theta, ro);\r\n\r\n    uv.y -= iTime * 0.65;\r\n    uv.y = opRep(uv, vec2(1.5)).y;\r\n\r\n    // Small perturbation of base circle\r\n    uv.y += 0.005 * (sin(-iTime * 1.8 + theta * 8.0 * PI) + sin(iTime * 4.0 + theta * 32.0 * PI));\r\n\r\n    float fftFreq = wave * clamp(0.0, 1.0, ro * 1.0) * 2.0 + 64.0;//10.0 + wave * 128.0;\r\n    float fftX = floor(uv.x * fftFreq);\r\n    float fftCoord1 = clamp(0.0, 1.0, fftX / fftFreq);\r\n\tfloat fft1 = sampleFFT(fftCoord1);\r\n\r\n    float fftCoord = (fftX - 1.0) / fftFreq;\r\n    float fft = sampleFFT(fftCoord);\r\n\r\n    float fftCoord2 = (fftX + 1.0) / fftFreq;\r\n    float fft2 = sampleFFT(fftCoord2);\r\n\r\n    float fftCoord3 = (fftX + 2.0) / fftFreq;\r\n    float fft3 = sampleFFT(fftCoord3);\r\n\r\n    float f = 0.6 * Catmull_Rom(fract(uv.x * fftFreq), fft, fft1, fft2, fft3);\r\n\r\n    float s = (0.01 + 1.6 * f) / abs(f-uv.y);\r\n    s = pow(s, 2.0 - wave * 0.6 - ro * 0.45 * (0.8 + 0.4 * wave));\r\n    s *= smoothstep(0.8, 0.0, uv.y);\r\n    s *= smoothstep(0.8, 0.0, -uv.y);\r\n\r\n\tcol += s;\r\n    col += 1.0 - smoothstep(0.0, 0.1, ro);\r\n    //col += fft - uv.y;\r\n    col *= vec3(0.1 + f * 1.5, 0.2,1.0 - f * 1.0);\r\n\r\n\t// output final color\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"XsXGRf",name:"Psychedelic lines by Andre",shader:"// https://www.shadertoy.com/view/XsXGRf\r\n#define StepSize .5\r\n#define LineCount 30\r\n\r\n//Function to draw a line, taken from the watch shader\r\nfloat line(vec2 p, vec2 a, vec2 b, float thickness, float extend )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba),-extend,1.0 + extend);\r\n\treturn 1.0 - smoothstep(thickness * 0.8, thickness * 1.2, length(pa - ba * h));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\r\n\r\n\tvec2 wav = vec2(length(texture(iChannel0, vec2(uv.x, 1)).xyz),\r\n\t\t\t\t\tlength(texture(iChannel0, vec2(uv.y, 1)).xyz));\r\n    // wav *= 3.0;\r\n    //vec4 spec = texture(iChannel0, vec2(uv.y, 0));\r\n\r\n\tuv *= 2.0 - 1.0 ;\r\n    float extend  = wav.y;\r\n\r\n\t// convert the input coordinates by a cosinus\r\n\t// warpMultiplier is the frequency\r\n\tfloat warpMultiplier = (6.0 + 1.5 * sin(iTime * 0.125));\r\n\tvec2 warped = cos(uv * 6.28318530718 * warpMultiplier)-cos(uv.yx*17.77*sin(iTime)+iTime)+ 0.1*wav.xy-sin(uv.xy+iTime);\r\n\r\n\r\n\tfloat gt = iTime*2.0;//floor(iTime * 20.0) * StepSize;\r\n\r\n\r\n\t// blend between the warpeffect and no effect\r\n\t// don't go all the way to the warp effect\r\n\tfloat warpornot = smoothstep(.5, 18.0, 2.0*sin(iTime * .25)+warped.x+warped.y)*0.15;\r\n\r\n\t// Variate the thickness of the lines\r\n\tfloat thickness = pow(1.5- 1.45 * cos(iTime), 2.0) / iResolution.x - wav.x*0.003 + wav.y*0.003;\r\n\t// thickness *= .1 + (warpMultiplier * warpornot)  + wav.x + wav.y;\r\n\r\n    float brighness = .2/pow(thickness,.5);\r\n\t// Add 10 lines to the pixel\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\r\n\tfor (int i = 0; i < LineCount; i++)\r\n\t{\r\n\t\tgt += StepSize;\r\n\r\n\t\tthickness *= 1.25;\r\n        brighness *= 1.0/1.25;\r\n\t\tuv = mix(uv, warped, warpornot);\r\n\r\n\t\t//Calculate the next two points\r\n\t\tvec2 point1 = vec2(sin(gt * 0.39), cos(gt * 0.23));\r\n\t\tvec2 point2 = vec2(cos(gt * 0.29), sin(gt * 0.22));\r\n\r\n\t\t// Add new line\r\n\t\tcolor.rgb += line(\tuv,\r\n\t\t\t\t\t\t\tpoint1, point2,\r\n\t\t\t\t\t\t\tthickness,extend)\r\n\t\t\t\t\t//With color\r\n\t\t\t\t\t* ( brighness +\r\n\t\t\t\t\t\tbrighness * vec3(\tsin(gt * 1.73),\r\n\t\t\t\t\t\t\t\t\tcos(gt * 2.19),\r\n\t\t\t\t\t\t\t\t\tsin(gt * 1.67)));\r\n}\r\n\r\n\t// Clamp oversaturation\r\n\tfragColor = clamp(color, 0.0, 1.0);\r\n}\r\n"},{id:"4ltcDj",name:"skulls by nabr",shader:"// https://www.shadertoy.com/view/4ltcDj\r\n// nabr\r\n// https://www.shadertoy.com/view/4ltcDj\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\r\n\r\n\r\n\r\n#define time iTime\r\n#define _ vec2((fragCoord.xy*2.001-iResolution.xy )/iResolution.y)\r\n\r\n#define pi 3.14159265359\r\n#define pi2 6.28318530718\r\n\r\nfloat music(vec2 r){\r\n\r\n    // ----- music texture https://www.shadertoy.com/view/Xds3Rr\r\n\r\n \t// the sound texture is 512x2\r\n    int tx = int( r.x * 512.0);\r\n\r\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\r\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x ;\r\n\r\n    // second row is the sound wave, one texel is one mono sample\r\n    return texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // music texture\r\n    float m = (music( abs(_) / 22.001 ))* .5 +.5 ;\r\n\r\n    // make a tunnel\r\n    float a = (.5+atan( length ( _ ), 1. ) * pi2);\r\n    float r = clamp(  a - acos(  _.y * 1.18 ) / pi2, 0., 1.);\r\n\r\n    // animate\r\n    // https://en.wikipedia.org/wiki/Shadertoy#Usage\r\n    vec2 uv =  vec2( 1./r + 0.2* time, m+a );\r\n    float f = sin(uv.x) * cos ( time  - uv.y);\r\n\r\n    // grid overlay\r\n    float grid = abs(0.01/ sin(  f + _.x * 12.) - f * cos( _.y))\r\n        \t\t - uv.y * abs(0.0015 / sin( f - _.y * 12.) - .081/cos(f*_.x));\r\n\r\n    // shade\r\n    vec3 col = (grid * 0.5) + (0.25 * cos(time- 0.25 + (pi2 * grid) + vec3( -pi/2., pi/2.6, pi )));\r\n\r\n    fragColor.rgb =  grid + pow(col + 0.2 , 2.2 / vec3( uv.x, uv.y , 1.-(uv.x+uv.y) ) );\r\n    fragColor.a = 1.;\r\n}\r\n"},{id:"WlSyWt",name:"PsyTrance by arminkz",shader:"// https://www.shadertoy.com/view/WlSyWt\r\nvec2 path(float t) {\r\n    float a = 1.,b=sin(t*.2);\r\n    return vec2(a*2., a*b);\r\n}\r\n\r\nfloat getSound(float i) {\r\n    return texture( iChannel0, vec2( 0.05 + 0.5*i/16.0, 0.25 ) ).x;\r\n}\r\n\r\nmat2 r2d(float a) {\r\n    float c=cos(a+7.*getSound(3.)+4.*getSound(1.)),s=sin(a+2.*getSound(3.)+4.*getSound(1.));\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n    p.x = abs(p.x) - d.x;\r\n    p.y = abs(p.y) - d.y;\r\n    if(p.y>p.x)p=p.yx;\r\n}\r\n\r\nfloat g=0.;\r\nfloat de(vec3 p) {\r\n\r\n    vec3 q = p;\r\n    q.x += q.z*.1;\r\n    q.z += iTime*.1;\r\n    q = mod(q-1., 2.)-1.;\r\n    float s = length(q) - .001 + sin(iTime*40.)*.005;\r\n\r\n    p.xy -= path(p.z);\r\n\r\n    p.xy *= r2d(p.z*.9);\r\n    mo(p.xy, vec2(.6, .12));\r\n    mo(p.xy, vec2(.9, .2));\r\n\r\n    p.xy *= r2d(p.z*.5);\r\n\r\n    mo(p.zy, vec2(.1, .2));\r\n    p.x = abs(p.x) - .4;\r\n    float d = length(p.xy) - .02 - (.5+.5*sin(p.z))*.05;\r\n\r\n    d = min(d, s);\r\n\r\n\r\n    g+=.01/(.01+d*d);\r\n    return d;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy -.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n\r\n    float dt = iTime * 6. + .5*sin(getSound(10.));\r\n    vec3 ro = vec3(0,0, -3. + dt);\r\n    vec3 ta = vec3(0, 0, dt);\r\n\r\n    ro.xy += path(ro.z);\r\n    ta.xy += path(ta.z);\r\n\r\n    vec3 fwd = normalize(ta -ro);\r\n    vec3 left = cross(vec3(0,1.0,0),fwd);\r\n    vec3 up = cross(fwd, left);\r\n\r\n    vec3 rd = normalize(fwd + left*uv.x+up*uv.y);\r\n\r\n    vec3 p;\r\n    float ri,t=0.;\r\n    for(float i=0.;i<1.;i+=.01) {\r\n    \tri = i;\r\n        p=ro+rd*t;\r\n        float d = de(p);\r\n        if(d<.001) break;\r\n        t+=d*.2;\r\n    }\r\n\tvec3 bg =  vec3(sin(0.5*dt), cos(dt+getSound(9.)), sin(getSound(6.)))*.3;\r\n    vec3 col = mix(vec3(.1, sin(dt), cos(dt)), bg,ri);\r\n    col += g*(.02);\r\n\r\n    col = mix(col, bg, 1.-exp(-.01*t*t));\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"ssXfD7",name:"My light show by Effickx",shader:"// https://www.shadertoy.com/view/ssXfD7\r\n#define yellow vec3(248.0, 223.0, 118.0)/256.0\r\n#define gray vec3(69.0, 41.0, 52.0)/256.0\r\n#define red vec3(255.0, 74.0, 68.0)/256.0\r\n#define green vec3(0.0, 255.0, 0.0)/256.0\r\n#define blue vec3(.0, 74.0, 255.0)/256.0\r\n\r\nvec3 circles(\r\n    vec2 uv,\r\n    vec2 position,\r\n    vec3 circles_color\r\n) {\r\n    return circles_color *\r\n    smoothstep(\r\n        (cos(iTime)+1.0)/4.0+0.5,\r\n        0.0,\r\n        length((uv+position)*length(fract(uv*5.0)-0.5))\r\n    );\r\n}\r\n\r\nmat2 rotate2d(float _angle){\r\n    return mat2(cos(_angle),-sin(_angle),\r\n                sin(_angle),cos(_angle));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float lowf=texelFetch( iChannel0, ivec2(0,0), 0 ).x;\r\n    float medf=texelFetch( iChannel0, ivec2(127,0), 0 ).x;\r\n    float highf=texelFetch( iChannel0, ivec2(511,0), 0 ).x;\r\n\r\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\r\n    uv=uv+vec2(cos(iTime/3.),sin(iTime/5.0));\r\n    uv=uv*rotate2d(iTime/3.0);\r\n\r\n    vec3 color=vec3(0);\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*4.0), sin(iTime/5.0*3.0)),\r\n        blue\r\n    )*highf*4.;\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*6.0), sin(iTime/5.0*7.0)),\r\n        green\r\n    )*lowf;\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*2.0), sin(iTime/5.0*5.0)),\r\n        red\r\n    )*medf*5.;\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"7lscWM",name:"abstract_audio_react by leamlld",shader:"// https://www.shadertoy.com/view/7lscWM\r\n// HELLO\r\n\r\n#define sound (texture(iChannel0, vec2(0.001,0.25)).x)\r\n\r\n\r\n//FORMES\r\n\r\nfloat sdSphere(vec3 c,vec3 p, float r)\r\n{\r\n    //return distance(p, c) - r + texture(iChannel1,(p.xy/p.xz/p.xx/p.xx)*(p.zx/p.zy/p.zz)*(p.yx/p.yy/p.yz)*clamp(sound,0.2,0.8)).r;\r\n    return distance(p, c) - r + (p.x/p.x/p.x/p.x/p.x)+(p.z/p.z/p.z/p.z/p.z)+(p.y/p.y/p.y/p.y/p.y)+clamp(sound,0.2,1.)*sound*2. ;\r\n}\r\n\r\n//DISPL\r\nfloat getDist(vec3 p)\r\n{\r\n    // Setup scene\r\n    return sdSphere(vec3(1.),p, 1.);\r\n}\r\n\r\n// ROTATION\r\n\r\nmat4 rotation3d(vec3 axis, float angle) {\r\n  axis = normalize(axis);\r\n  float s = sin(angle);\r\n  float c = cos(angle);\r\n  float oc = 1.0 - c;\r\n\r\n  return mat4(\r\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r\n        0.0,                                0.0,                                0.0,                                1.0\r\n    );\r\n}\r\n\r\nvec3 rotate(vec3 v, vec3 axis, float angle) {\r\n    return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\r\n}\r\n\r\n\r\n// PALETTES\r\n\r\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\r\n{\r\n    return a + b*cos( 61.28318*(c*t+d) );\r\n}\r\n\r\n\r\nfloat map(vec3 pos) // position 3d de la marche\r\n{\r\n\r\n\r\n\r\n    float volume = 0.0;\r\n\r\n    pos.x+= sin(iTime);\r\n    pos.y += cos(iTime);\r\n\r\n    pos.z +=sound;\r\n    float sphere = sdSphere( vec3(5.), pos +vec3(1.,-2.,0.) , 2.5);\r\n\r\n    volume=sphere;\r\n    return volume;\r\n}\r\n\r\n\r\nfloat CastRay(vec3 ro, vec3 rd)\r\n{\r\n\r\n\r\n    float c = 0.0; // contact\r\n    for (int i = 0; i<60;i++)\r\n    { // nombre de pas du ray\r\n        float ray = map(ro+rd*c);\r\n        if(ray<(0.0001*c))// distance min = contact\r\n        {\r\n            return float(i)/32.;\r\n        }\r\n\r\n        c+= ray;\r\n    }\r\n\r\n    return -1.0;\r\n\r\n}\r\n\r\nvec3 render(vec3 ro, vec3 rd)\r\n{\r\n\r\n\r\n    float contact = CastRay(ro,rd); // appel du raycast\r\n    vec3 col = vec3(0.0); // couleur de base du pixel\r\n\r\n    if (contact ==-1.)// sil ny a pas de contact\r\n    {\r\n\r\n        col=vec3(0.);// couleur du fond\r\n\r\n    }\r\n    else\r\n    {\r\n        //vec3 nor = GetNormal(ro+rd * contact);\r\n        //col= vec3(1.-contact); // couleur du volume (blanc)\r\n\r\n        float depth = vec3(1.-contact).r;\r\n        col = palette(depth ,vec3(0.5),vec3(0.5),vec3(1.),vec3(clamp(sound,0.1,0.8),0.3,0.37));\r\n\r\n\r\n    }\r\n\r\n    return col;\r\n\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    //vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\r\n\r\n\r\n    // parametres camera\r\n    vec3 cameraPos = vec3(10., 10., 10.);;\r\n\r\n\r\n    vec3 cameraTar = vec3(0.0, 2.0, 0.0);\r\n\r\n    // vecteur de direction depuis la cam\r\n\r\n    vec3 forward= normalize(cameraTar- cameraPos);\r\n    vec3 right = normalize (cross(vec3(0.,-1.,0.),forward));\r\n    vec3 up = normalize (cross(right,forward));\r\n    vec3 viewDir = normalize (uv.x* right + uv.y * up + 2. * forward);\r\n\r\n\r\n    ///vec3 col;\r\n    vec3 col = render(cameraPos,viewDir);\r\n\r\n\r\n\r\n    //affichage des uv\r\n    //vec3 col = render(cameraPos,viewDir);\r\n\r\n    fragColor =vec4 (col,1.);\r\n\r\n\r\n\r\n\r\n}\r\n"},{id:"ldsXWH",name:"solarDance [mod1] by entropynine",shader:"// https://www.shadertoy.com/view/ldsXWH\r\n// based on https://www.shadertoy.com/view/lsf3RH by\r\n// trisomie21 (THANKS!)\r\n// modified only for learning fun\r\n\r\nfloat snoise(vec3 uv, float res)\t// code modded from trisomie21\r\n{\r\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\r\n\r\n\tuv *= res;\r\n\r\n\tvec3 uv0 = floor(mod(uv, res))*s;\r\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\r\n\r\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\r\n\r\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\r\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\r\n\r\n\tvec4 r = fract(sin(v*1e-3)*1e5);\r\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\r\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\r\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\r\n\treturn mix(r0, r1, f.z)*2.-1.;\r\n}\r\n\r\nfloat freqs[4];\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\r\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\r\n\tfloat invRadius \t= 1.0/radius;\r\n\r\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\r\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\r\n\tfloat time\t\t= iTime * 0.1;\r\n\tfloat aspect\t= iResolution.x/iResolution.y;\r\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\r\n\tvec2 p \t\t\t= -0.5 + uv;\r\n\tp.x *= aspect;\r\n\r\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\r\n\tfloat fVal1\t\t= 1.0 - fade;\r\n\tfloat fVal2\t\t= 1.0 - fade;\r\n\r\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\r\n\tfloat dist\t\t= length(p);\r\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\r\n\r\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\r\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\r\n\tfor( int i=1; i<=7; i++ ){\r\n\t\tfloat power = pow( 2.0, float(i + 1) );\r\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\r\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\r\n\t}\r\n\r\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.5*sin(iTime) ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t*= 1.2 - newTime1;\r\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\r\n\tvec3 dir \t\t\t= vec3( 0.0 );\r\n\tvec3 center\t\t\t= vec3( 0.5, 0.5*sin(iTime), 1.0 );\r\n\tvec3 starSphere\t\t= vec3( 0.0 );\r\n\r\n\tvec2 sp = -1.0 + 2.0 * uv;\r\n\tsp.x *= aspect;\r\n\tsp *= ( 2.0 - brightness );\r\n  \tfloat r = dot(sp,sp);\r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5*sin(iTime);\r\n\tif( dist < radius ){\r\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\r\n  \t\tvec2 newUv;\r\n \t\tnewUv.x = sp.x*f;\r\n  \t\tnewUv.y = sp.y*f;\r\n\t\tnewUv += vec2( time, 0.0 );\r\n\r\n\t\tvec3 texSample \t= texture( iChannel1, newUv ).rgb;\r\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\r\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\r\n\t\tstarSphere\t\t= texture( iChannel1, starUV ).rgb;\r\n\t}\r\n\r\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\r\n\t//fragColor.rgb\t= vec3( r );\r\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\r\n\tfragColor.a\t\t= 1.0;\r\n}\r\n"},{id:"7slGWj",name:"Beat of broken hearts by Hultsborn10",shader:"// https://www.shadertoy.com/view/7slGWj\r\nfloat RAYS = 54.0;\r\n//https://soundcloud.com/castorcinema/beat-of-broken-hearts-feat\r\n//https://soundcloud.com/clemenswenners/africa\r\n//https://soundcloud.com/noa-edwardsson/we-are-the-ones\r\n//https://soundcloud.com/br-ndon-kucharek/rings-of-saturn-utopia\r\n//https://soundcloud.com/mukunda-mtandari/smooth-and-sexy-smooth-jazz-for-lovers\r\n\r\nfloat R21(vec2 uv)\r\n{\r\n    float a = abs(sin(uv.x*1.1));\r\n    float b = abs(cos(uv.y*104.7));\r\n    return(a*b);\r\n}\r\n\r\n\r\n//Avståndet mellan punkten p och linjen från a till b\r\nfloat DistLine(vec2 p, vec2 a, vec2 b)\r\n{\r\n    vec2 ap = p-a;\r\n    vec2 ab = b-a;\r\n    //Längden av skuggan av ap utmed ab\r\n    float lShadow = dot(ap, ab);\r\n    //Längden av ab\r\n    float lab = dot(ab, ab);\r\n    //Låt t bli kvoten (andelen) av ab som skuggan utgör\r\n    //Se till att den inte blir negativ\r\n    float t = clamp(lShadow/lab, 0.0, 1.0);\r\n    //Ta fram vektorn från punkten p till toppen av skuggan,\r\n    vec2 sp = ap - ab*t;\r\n    //returnera längden av den nya vektorn\r\n    return length(sp);\r\n}\r\n\r\nfloat GetDist(vec2 uv, vec2 rayP)\r\n{\r\n    vec2 origin = vec2(0.0,0.0);\r\n    float d = DistLine(uv, origin, rayP);\r\n    float w = 0.05;\r\n    float wz = 0.01;\r\n    float c = smoothstep(w/RAYS, w/RAYS+wz, d);\r\n    /*\r\n    vec2 top = vec2(0.0, 5.0 );\r\n    vec2 bottom = vec2(0.0, -5.0);\r\n    vec2 lef = vec2(-5.0, 0.0);\r\n    vec2 rig = vec2(5.0, 0.0);\r\n    float d1 = DistLine(uv, top, bottom);\r\n    float d2 = DistLine(uv, lef, rig);\r\n    c = min(d1,d2);\r\n    */\r\n    //return smoothstep(0.5, 0.0, c);\r\n    return c;\r\n}\r\n\r\nvec2 GetRayPoint(float rayNumber, float length)\r\n{\r\n    float angle = rayNumber/RAYS*6.28;\r\n    float x = cos(angle)*length;\r\n    float y = sin(angle)*length;\r\n    vec2 p = vec2(x,y);\r\n    return p;\r\n}\r\n\r\nvec2 Rotate(vec2 uv, float angle){\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    float x = c*uv.x + s*uv.y;\r\n    float y = s*uv.x - c*uv.y;\r\n    return vec2(x,y);\r\n}\r\n\r\nfloat GetRayNumber(vec2 uv)\r\n{\r\n    //Beräkna en vinkel som går från -0.5 till 0.5\r\n    float angle = (atan(uv.y, uv.x)/6.28);\r\n    //Multiplicera med antalet strålar\r\n    float ray = angle*RAYS;\r\n    return ray;\r\n}\r\n\r\nfloat GetRayWheel(vec2 uv, float freqOffset, float raylength, float rotate)\r\n{\r\n    uv = Rotate(uv, rotate);\r\n    float ray = GetRayNumber(uv);\r\n    //Raycenter är ett heltal från -antal strålar/2 till +RAYS/2\r\n    float raycenter = floor(ray);\r\n    //Ta fram längden på strålen från frekvensspektrat i musiken\r\n    float frequency = raycenter + RAYS/2.0;\r\n    if (frequency < 0.1) frequency = RAYS;\r\n    frequency += freqOffset;\r\n    float fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\r\n\r\n    //Beräkna avståndet till de två närmaste strålarna\r\n    vec2 p = GetRayPoint(raycenter, fft);\r\n    float d = (1.0-GetDist(uv, p));\r\n    //Första halva topp-punkten\r\n    float pSize = 0.99;\r\n    float pc = smoothstep(pSize, 1.0, 1.0-length(uv-p));\r\n    //Blinkning till topp-punkten\r\n    float pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\r\n    pc *=pcBlink;\r\n\r\n    raycenter = ceil(ray);\r\n    frequency = raycenter + RAYS/2.0;\r\n    if (frequency < 0.1) frequency = RAYS;\r\n    frequency += freqOffset;\r\n    //Ta fram längden på strålen från frekvensspektrat i musiken\r\n    fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\r\n    p = GetRayPoint(raycenter, fft);\r\n    d += (1.0-GetDist(uv, p));\r\n    float c = d*length(uv);\r\n    //Blinkning till topp-punkten\r\n    if ((RAYS/2.0-raycenter)<0.1) raycenter = -raycenter;\r\n    pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\r\n    //Andra halvan av topp-punkten\r\n    pc += smoothstep(pSize, 1.0, 1.0-length(uv-p))*pcBlink;\r\n    c *= R21(uv);\r\n    return 10.0*c+25.0*pc;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from -0.5 to 0.5 vertically)\r\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\r\n    //uv*=0.5;\r\n    uv = Rotate(uv,-iTime*0.1);\r\n    //vec3 col = vec3(0.9, 0.2 , 0.1);//röd-orange\r\n    vec3 col = 0.3+0.3*vec3(sin(iTime*0.5),sin(iTime*0.4),sin(iTime*0.3));\r\n    float c = GetRayWheel(uv, 0.0, 1.0, 0.0);\r\n    //float rotation = 3.14/RAYS;\r\n    //\r\n    float rotation = -iTime*0.1;\r\n    c += 1.4*GetRayWheel(uv, 2.0*RAYS, 0.4, rotation);\r\n    //\r\n    rotation = -iTime*0.2;\r\n    c += 1.4*GetRayWheel(uv, RAYS, 0.75, rotation);\r\n    col *= c;\r\n    //en ljus cirkel\r\n    float d = 1.0-length(uv);\r\n    vec3 dcol = vec3(0.5, 0.5, 0.1);\r\n    col += d*dcol;\r\n    //en vit cirkel\r\n    d = smoothstep(0.8, 1.0,1.0-length(uv));\r\n    dcol = vec3(.5);\r\n    col += d*dcol;\r\n    //col = d*dcol;\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"3sfXRj",name:"Issues - Don Toliver by IsaacAndersen",shader:"// https://www.shadertoy.com/view/3sfXRj\r\nfloat line(vec2 p, vec2 p0, vec2 p1)\r\n{\r\n    vec2 a = p-p0; // the vector that we want to project on b\r\n    vec2 b = p1-p0; // this line is our goal.\r\n\r\n    vec2 proj = clamp((dot(a,b)/dot(b,b)),0.0,1.0)*b; // vector projection of a onto b\r\n    vec2 rejc = a-proj; // vector rejection or distance in other words\r\n\r\n    return smoothstep(0.0,1.2,1.0-dot(rejc, rejc)*1e4);\r\n} // stolen: https://www.shadertoy.com/view/4d3fWr\r\n\r\nvec2 random12(float i) {\r\n    return normalize(vec2(sin(329.34+131.8*sin(722.1*i+8.23)),\r\n                sin(494.34+2871.1*sin(431.1*i+415.39))));\r\n}\r\n\r\nfloat random (in vec2 _st) {\r\n    return fract(sin(dot(_st.xy,\r\n                         vec2(12.9898,78.233)))*\r\n        43758.5453123);\r\n}\r\n\r\n// Based on Morgan McGuire @morgan3d\r\n// https://www.shadertoy.com/view/4dS3Wd\r\nfloat noise (in vec2 _st) {\r\n    vec2 i = floor(_st);\r\n    vec2 f = fract(_st);\r\n\r\n    // Four corners in 2D of a tile\r\n    float a = random(i);\r\n    float b = random(i + vec2(1.0, 0.0));\r\n    float c = random(i + vec2(0.0, 1.0));\r\n    float d = random(i + vec2(1.0, 1.0));\r\n\r\n    vec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(a, b, u.x) +\r\n            (c - a)* u.y * (1.0 - u.x) +\r\n            (d - b) * u.x * u.y;\r\n}\r\n\r\n#define NUM_OCTAVES 5\r\n\r\nfloat fbm ( in vec2 _st) {\r\n    float v = 0.0;\r\n    float a = 0.5;\r\n    vec2 shift = vec2(100.0);\r\n    // Rotate to reduce axial bias\r\n    mat2 rot = mat2(cos(0.5), sin(0.5),\r\n                    -sin(0.5), cos(0.50));\r\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\r\n        v += a * noise(_st);\r\n        _st = rot * _st * 2.0 + shift;\r\n        a *= 0.5;\r\n    }\r\n    return v;\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy;\r\n    vec2 uv = ( U - 0.5*R) / R.y;\r\n    float t = iTime/2.;\r\n\r\n    float angle1 = (3.1415)* (t/4.0);\r\n\r\n    float s1 = sin(angle1);\r\n    float c1 = cos(angle1);\r\n\r\n    uv *= mat2(c1, -s1, s1, c1);\r\n\r\n\r\n  \tvec2 bgUV = uv * 10.;\r\n\r\n\tvec3 col = vec3(124,41,212)/255.0;\r\n\r\n\r\n\r\n    float m = texture( iChannel0, vec2(1.,0.25) ).x;;\r\n\r\n    float col_1 = -fbm(bgUV + vec2(t,0.)+fbm(bgUV + t));\r\n\r\n\tcol += col_1;\r\n\r\n    vec3 col2 = vec3(0);\r\n\r\n    float numChannels = 16.; // all 512 seems overkill\r\n    float maxFreq = 0.;\r\n    for(float i = 0.; i < 1.; i += 0.0625) {\r\n        float fft  = texture( iChannel0, vec2(i,0.25) ).x;\r\n\r\n        for(float j = 0.; j < 4.;j+= 1.) {\r\n            vec2 segment = random12(i+j)*fft;\r\n            col2 += line(uv, vec2(0),segment*fbm(segment+t))*fft;\r\n        }\r\n\r\n    }\r\n\r\n    col2 *= 0.4 + 0.6*sin(18.*smoothstep(-1.,1.,m)*(1.0-length(uv)));\r\n\r\n    col += col2;\r\n\r\n\t// output final color\r\n\tO = vec4(col,1.0);\r\n}\r\n"},{id:"3t3yRl",name:"Shamosis - Dinopwaur by z0rg",shader:"// https://www.shadertoy.com/view/3t3yRl\r\n// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/\r\n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\r\n// =========================================================================================================\r\n\r\n#define FFT(p) pow(texelFetch(iChannel0, ivec2(int(p), 0), 0)*.45, vec4(4.5))\r\n\r\nfloat lenny(vec2 v)\r\n{\r\n  return abs(v.x)+abs(v.y);\r\n}\r\n#define sat(a) clamp(a, 0.,1.)\r\nmat2 r2d(float a)\r\n{\r\n  float ca = cos(a);\r\n  float sa = sin(a);\r\n\r\n  return mat2(ca,-sa, sa, ca);\r\n}\r\nvec2 _sub(vec2 a, vec2 b)\r\n{\r\n  if (a.x > -b.x)\r\n    return a;\r\n  return b;\r\n}\r\n\r\nvec2 _min(vec2 a, vec2 b)\r\n{\r\n  if (a.x < b.x)\r\n    return a;\r\n  return b;\r\n}\r\nfloat sdCylinder( vec3 p, vec3 c )\r\n{\r\n  return length(p.xz-c.xy)-c.z;\r\n}\r\n\r\n// power smooth min (k = 8);\r\nfloat _smin( float a, float b, float k )\r\n{\r\n    a = pow( a, k ); b = pow( b, k );\r\n    return pow( (a*b)/(a+b), 1.0/k );\r\n}\r\n\r\nvec3 getDir(vec3 rd, vec2 uv)\r\n{\r\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\r\n  vec3 u = normalize(cross(r, rd));\r\n\r\n  return rd+ r * uv.x + u * uv.y;\r\n}\r\n\r\nfloat rhombus(vec3 p, float sz)\r\n{\r\n  p = abs(p);\r\n  return (p.x+p.y+p.z-sz)*0.577;\r\n}\r\n\r\n\r\nvec2 map(vec3 p)\r\n{\r\n  float beat = FFT(5).x*3.;\r\n  vec2 cyl = vec2(sdCylinder(p, vec3(1., 1., 1.)), 0.);\r\n  vec3 p2 = p;\r\n  p2.xz += vec2(sin(beat), cos(beat))*4.;\r\n  vec2 sph = vec2(length(p2)-2.5*max(FFT(55).x, 0.007)*70., 0.);\r\n  p2 = p+vec3(1.);\r\n  vec2 sph2 = vec2(rhombus(p2, 5.5*max(FFT(205).x, 0.005)*70.), 0.);\r\n  return _min(_min(sph2, sph), cyl);\r\n  vec2 fl = vec2(p.y, 1.);\r\n  return _min(cyl, fl);\r\n}\r\n\r\nvec3 calcNormal( in vec3 p, in float t )\r\n{\r\n    float e = 0.001*t;\r\n\r\n    vec2 h = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( h.xyy*map( p + h.xyy*e ).x +\r\n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x +\r\n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x +\r\n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\r\n}\r\n\r\nvec3 checkerBoard(vec2 uv)\r\n{\r\n  uv.y+=iTime*5.;\r\n  float sz = 1.5;\r\n  float x = mod(uv.x, sz)-sz*.5;\r\n  float y = mod(uv.y, sz)-sz*.5;\r\n  x = sat(x*200.);\r\n  float res = mix(x, 1.-x, sat(y*200.));\r\n  return vec3(res);\r\n}\r\n\r\nvec3 grad(vec2 uv)\r\n{\r\n  vec3 col;\r\n  vec3 blue = vec3(157., 200., 255.)/255.;\r\n  vec3 yellow = vec3(255, 241., 187.)/255.;\r\n  vec3 red = vec3(255., 190., 191.)/255.;\r\n\r\n  float sz = 19.;\r\n\r\n  if (uv.y < 0.)\r\n  {\r\n    return mix(yellow, red, sat(-uv.y*sz));\r\n  }\r\n\r\n\r\n  return mix(yellow, blue, sat(uv.y*sz));\r\n}\r\n\r\nfloat sig(vec2 uv)\r\n{\r\n  float attenBorder = 1.;\r\n  float t = iTime;// iTime;\r\n  float tst = sin(abs(uv.x)*5.+t)*.002;\r\n  return uv.y -.01- (attenBorder*sat(FFT(abs(uv.x*.005)).x*5.))*.05-tst;//*(1.-sat(abs(uv.x*2.)), 5.);\r\n}\r\n\r\nvec3 rdr(vec2 uv)\r\n{\r\n  vec3 col;\r\n  col = vec3(0.123, 0.07, 0.15);\r\n\r\n  vec3 rgb = pow(grad(uv), vec3(1.45));\r\n  rgb.x *= .6+sat(FFT(uv.x*.1).x)*100.;\r\n\r\n  vec2 ouv = uv;\r\n  uv = vec2(atan(uv.y, uv.x), length(uv));\r\n  float ln = abs(sig(uv))-.00001;\r\n\r\n    col = mix(col, rgb, 1.-sat(ln*800.));\r\n    col += rgb *pow(1.-sat(ln*10.), 5.);\r\n\r\n\r\n  for (int i = 0; i < 8; ++i)\r\n  {\r\n    float fi = float(i);\r\n\r\n    vec2 uvt = ouv * r2d(fi);\r\n    uvt = vec2(atan(uvt.y, uvt.x), length(uvt));\r\n    float ln2 = abs(sig(uvt*fi/8.))-.00001*fi*fi;\r\n\r\n    col += .3*rgb *pow(1.-sat(ln2*950.), 5.);\r\n\r\n  }\r\n\r\n\r\n  return col;\r\n}\r\n\r\n\r\n\r\nvec2 myPixel(vec2 uv, float k)\r\n{\r\n  vec2 pxuv = uv/k;\r\n  pxuv = vec2(int(pxuv.x), int(pxuv.y))*k;\r\n  return pxuv;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\r\n uv *= .2;\r\n\r\n\r\n\r\n  float rep = 1.+(sin(iTime*.5) < 0. ? 1. : sat(FFT(5).x*50.));\r\n\r\n  if (false)//iTime > 78.8)\r\n  {\r\n\r\n  float rep2 = .1*sin(iTime*.5);\r\n  uv *= r2d(sin(iTime+length(uv)*145.));\r\n  uv.x = mod(uv.x, rep2)-.5*rep2;\r\n  }\r\n  uv *= r2d(-3.14159265/2.);\r\n  uv *= mod(-iTime, 2.);\r\n  float r = 0.05/(sin(iTime));\r\n  uv *= r2d(mod(length(uv), r)/r);\r\n\r\n  vec2 uv2 = uv;\r\n  uv2.x = (mod(atan(uv.y, uv.x), rep)-.5*rep)*.1;\r\n  uv2.y = FFT(abs(uv.y)).x+length(uv)*(mod(iTime*.5, 2.5))+sin(iTime)*.05;\r\n\r\n  uv2 = myPixel(uv2, 0.01*sin(iTime*.5));\r\n\r\n  vec3 col =rdr(uv2)*.7;\r\n  col += rdr(uv)*.1*(sin(iTime*.2)*.5+.5);\r\n\tcol *= .5+rdr(uv*.2);\r\n    float a = atan(uv.y, uv.x);\r\n    col = mix(col, mix(col.zyx, col, 0.), sat(sin(uv.x*15.+iTime)+.1*sin(length(uv-a*3.14159265*2.-iTime))));\r\n  col = pow(col, vec3(1.45));\r\n  vec3 txt;// = texture(iChannel1, fragCoord/iResolution.xy).xyz;\r\n  col *= mix(vec3(1.), vec3(5.), txt.x);\r\n  //col *= sat(iTime-2.);\r\n  col *= 1.-sat(iTime-502.);\r\n  fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"WsGBDc",name:"Multicolor pixelated spiral by z0rg",shader:"// https://www.shadertoy.com/view/WsGBDc\r\n// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/\r\n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\r\n// =========================================================================================================\r\n\r\n// https://youtu.be/SIYvL_-OkR8\r\n\r\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\r\n\r\n#define PI 3.14159265\r\n#define sat(a) clamp(a,0.,1.)\r\n\r\nfloat lenny(vec2 uv)\r\n{\r\n  return abs(uv.x)+abs(uv.y);\r\n}\r\nfloat cir(vec2 p, float r)\r\n{\r\n  return length(p)-r;\r\n}\r\nfloat loz(vec2 p, float r)\r\n{\r\n  return lenny(p)-r;\r\n}\r\n\r\nvec3 rdr(vec2 uv, float t)\r\n{\r\n  vec3 col;\r\n\r\n  for (int i=0; i < 7; i++)\r\n  {\r\n    float fi = float(i);\r\n    for (int j=0; j < 7; j++)\r\n    {\r\n      float fj = float(j);\r\n      float a = fi*.5*t+(fj/7.)*PI*2.\r\n      +texelFetch(iChannel1, ivec2(int(fj*5.), 0), 0).x;\r\n      float lz = loz(uv+vec2(sin(a),cos(a))*(1.+fi)*(.25+.05*sin(iTime)),mix(.1,.2, fi/7.));\r\n      col = mix(col, vec3(1.),1.-sat(lz*400.));\r\n    }\r\n  }\r\n  //col += texture(iChannel0,uv+iTime*50.).xxx*.1;\r\n  col += sat(1.5+sin(uv.y*50.+t*20.))*.3*vec3(.9,.71,.54)*(1.-sat(lenny(uv*.2)));\r\n  col *= texelFetch(iChannel1, ivec2(0, 0), 0).x;\r\n  vec3 lzCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\r\n  col += .55*(1.-sat(lenny(uv*.1*vec2(1.,3.))))*lzCol*texelFetch(iChannel1, ivec2(55, 0), 0).x;\r\n  return col;\r\n}\r\n\r\nvec3 rdr2(vec2 uv)\r\n{\r\n  float dist = (sin(-iTime*5.+(uv.x+uv.y)*5.)*.5+1.)*0.05;//*(1.-sat(pow(length(uv)-.2,2.)));\r\n  vec2 dir = normalize(uv);\r\n  vec3 col;\r\n  float stp = 1./20.;\r\n  float t = float(int(iTime/stp))*stp*.25;\r\n  col.r = rdr(uv, t-.05).r;\r\n  col.g = rdr(uv,t).g;\r\n  col.b = rdr(uv,t+.05).b;\r\n  return col.yzx;\r\n}\r\n\r\nvec2 myPixel(vec2 uv, vec2 sz)\r\n{\r\n  vec2 tmp = uv / sz;\r\n\r\n  uv.x = float(int(tmp.x));\r\n  uv.y = float(int(tmp.y));\r\n  return (uv)*sz;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n  vec2 uv =( fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\r\n  uv = myPixel(uv,vec2(0.005));\r\n  uv*=5.7;\r\n\r\n  vec3 col = rdr2(uv);\r\n  col+=rdr2(uv*r2d(.1))*.5;\r\n  col *= .5+1.-sat(lenny(uv*.25));\r\n\r\n  float val = texture(iChannel2, fragCoord/iResolution.xy).x;\r\n\r\n  col *= sat(iTime-3.);\r\n  //col = mix(col, vec3(1.), val*.5);\r\n\r\n\r\n  fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"fd2GD1",name:"Shimmy by Kali",shader:"// https://www.shadertoy.com/view/fd2GD1\r\n#define iTime iChannelTime[0]\r\nfloat det=.005, maxdist=50., pi=3.1416, gl=0.;\r\nvec2 id;\r\n\r\n\r\nfloat hash12(vec2 p)\r\n{\r\n    p*=1000.;\r\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n\r\nmat2 rot(float a)\r\n{\r\n    float s=sin(a), c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\nfloat box(vec3 p, vec3 c)\r\n{\r\n    vec3 pc=abs(p)-c;\r\n    return length(max(vec3(0.),pc))-min(0.,max(pc.z,max(pc.x,pc.y)));\r\n}\r\n\r\nvec2 amod(vec2 p, float n, float off, out float i)\r\n{\r\n    float l=length(p)-off;\r\n    float at=atan(p.x,p.y)/pi*n*.5;\r\n    i=abs(floor(at));\r\n    float a=fract(at)-.5;\r\n    return vec2(a,l);\r\n}\r\n\r\nfloat ring(vec3 p,inout vec2 id)\r\n{\r\n    p.xy=amod(p.xy*rot(iTime*0.), 20., 2., id.x);\r\n    float h=max(0.,texture(iChannel0,vec2(.5+fract(id.x*.2+id.y*.1),0.)*.5).r*3.-.5);\r\n    h+=sin(iTime*10.+id.x)*.2;\r\n    float d=box(p+vec3(0.,-h*1.5,0.),vec3(.1,h,.1));\r\n    return d*.5;\r\n}\r\n\r\nfloat de(vec3 p)\r\n{\r\n    float d=100.,ii=0.;\r\n    p.xz*=rot(iTime);\r\n    p.yz*=rot(sin(iTime));\r\n    float r=4.;\r\n    vec2 ids;\r\n    for (float i=0.; i<4.; i++)\r\n    {\r\n        p.xz*=rot(pi/r);\r\n        ids.y=i;\r\n        float r=ring(p,ids);\r\n        if (r<d)\r\n        {\r\n            d=r;\r\n            id=ids;\r\n        }\r\n    }\r\n    d=min(d,length(p)-1.5);\r\n    return d*.7;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n    vec2 e=vec2(0.,det);\r\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\r\n}\r\n\r\n\r\nvec3 march(vec3 from, vec3 dir)\r\n{\r\n    float d, td=0.;\r\n    vec3 p, col=vec3(0.);\r\n    for (int i=0; i<100; i++)\r\n    {\r\n        p=from+td*dir;\r\n        d=de(p);\r\n        if (d<det || td>maxdist) break;\r\n        td+=d;\r\n        gl+=.1/(10.+d*d*10.)*step(.7,hash12(id+floor(iTime*5.)));\r\n    }\r\n    if (d<det)\r\n    {\r\n        //id+=floor(iTime*5.);\r\n        vec3 colid=vec3(hash12(id),hash12(id+123.123),1.);\r\n        p-=dir*det;\r\n        vec3 n=normal(p);\r\n        vec2 e=vec2(0.,.05);\r\n        col=.1+max(0.,dot(-dir,n))*colid;\r\n        col*=.5+step(.7,hash12(id+floor(iTime*5.)));\r\n    }\r\n    else\r\n    {\r\n        dir.xz*=rot(iTime*.5);\r\n        dir.yz*=rot(iTime*.25);\r\n        vec2 p2=abs(.5-fract(dir.yz));\r\n        float d2=100.,is=0.;\r\n        for(int i=0; i<10; i++)\r\n        {\r\n            p2=abs(p2*1.3)*rot(radians(45.))-.5;\r\n            float sh=length(max(vec2(0.),abs(p2)-.05));\r\n            if (sh<d2)\r\n            {\r\n                d2=sh;\r\n                is=float(i);\r\n            }\r\n        }\r\n        col+=smoothstep(.05,.0,d2)*fract(is*.1+iTime)*normalize(p+50.);\r\n    }\r\n    return col*mod(gl_FragCoord.y,4.)*.5+gl;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 from = vec3(0.,0.,-8.);\r\n    vec3 dir = normalize(vec3(uv,.7));\r\n    vec3 col = march(from, dir);\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"tlySzm",name:"Chromatic Resonance by PixelPhil",shader:"// https://www.shadertoy.com/view/tlySzm\r\n//\r\n// Chromatic Resonance by Philippe Desgranges\r\n// Email: Philippe.desgranges@gmail.com\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n//\r\n\r\n#define MUSIC_REACTION 0.2\r\n\r\n#define S(a, b, c) smoothstep(a, b, c)\r\n#define sat(a) clamp(a, 0.0, 1.0)\r\n\r\n#define pi 3.14159265359\r\n#define pi2 (pi * 2.0)\r\n#define halfPi (pi * 0.5)\r\n\r\n\r\n// Some hash function 2->1\r\nfloat N2(vec2 p)\r\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\r\n    p = mod(p, vec2(1456.2346));\r\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n\r\nfloat CosineInterpolate(float y1, float y2, float t)\r\n{\r\n   float mu = (1.0 -cos(t * pi)) * 0.5;\r\n   return (y1 * (1.0 - mu) + y2 * mu);\r\n}\r\n\r\n// A 2d Noise (Cosine interpolation is more plasing for this effect)\r\nfloat Noise2(vec2 uv)\r\n{\r\n    vec2 corner = floor(uv);\r\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\r\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\r\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\r\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\r\n\r\n    vec2 diff = fract(uv);\r\n\r\n    return CosineInterpolate(CosineInterpolate(c00, c10, diff.x), CosineInterpolate(c01, c11, diff.x), diff.y);\r\n}\r\n\r\nfloat LineNoise(float x, float t)\r\n{\r\n    float n = Noise2(vec2(x * 0.6, t * 0.2));\r\n    //n += Noise2(vec2(x * 0.8, t * 0.2 + 34.8)) * 0.5;\r\n    //n += Noise2(vec2(x * 1.2, t * 0.3 + 56.8)) * 0.25;\r\n\r\n    return n - (1.0) * 0.5;\r\n}\r\n\r\n\r\nfloat line(vec2 uv, float t, float scroll)\r\n{\r\n\r\n    float ax = abs(uv.x);\r\n    uv.y *= 0.5 + ax * ax * 0.3;\r\n\r\n\r\n    uv.x += iTime * scroll;\r\n\r\n    float n1 = LineNoise(uv.x, t);\r\n\r\n\r\n    float n2 = LineNoise(uv.x + 0.5, t + 10.0) * 2.0;\r\n\r\n    float ay = abs(uv.y - n1);\r\n    float lum = S(0.02, 0.00, ay) * 1.5;\r\n    lum += S(1.5, 0.00, ay) * 0.1;\r\n\r\n\r\n    float r = (uv.y - n1) / (n2 - n1);\r\n    float h = sat(1.0 - r);\r\n    if (r > 0.0) lum = max(lum, h * h * 0.7);\r\n\r\n    return lum;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n\r\n\r\n    float xWave = fragCoord.x / iResolution.x;\r\n\r\n    float wave = texture(iChannel0, vec2(xWave * 0.2, 1.0)).r * sin(iTime * 0.2 ) * MUSIC_REACTION;\r\n    float wave1 = texture(iChannel0, vec2(xWave * 0.2 + 0.2, 1.0)).r * sin(iTime * 0.2 + 0.5) * MUSIC_REACTION;\r\n    float wave2 = texture(iChannel0, vec2(xWave * 0.2 + 0.4, 1.0)).r * sin(iTime * 0.2 + 1.0) * MUSIC_REACTION;\r\n    float wave3 = texture(iChannel0, vec2(xWave * 0.2 + 0.6, 1.0)).r * sin(iTime * 0.2 + 1.5) * MUSIC_REACTION;\r\n    float wave4 = texture(iChannel0, vec2(xWave * 0.2 + 0.8, 1.0)).r * sin(iTime * 0.2 + 2.0) * MUSIC_REACTION;\r\n\r\n  //  fragColor = vec4(lum, lum, lum, 1.0); return;\r\n\r\n\r\n    float lum = line(uv * vec2(2.0, 1.0)+  vec2(0.0, wave), iTime * 0.3, 0.1) * 0.6;\r\n    lum += line(uv * vec2(1.5, 0.9) +  vec2(0.33, wave1), iTime * 0.5 + 45.0, 0.15) * 0.5;\r\n    lum += line(uv * vec2(1.3, 1.2) +  vec2(0.66, wave2), iTime * 0.4 + 67.3, 0.2) * 0.3;\r\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave3), iTime * 0.77 + 1235.45, 0.23) * 0.43;\r\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave4), iTime * 0.77 + 456.45, 0.3) * 0.25;\r\n\r\n\r\n    float ax = abs(uv.x);\r\n\r\n    lum += ax * ax * 0.05;\r\n\r\n\r\n    vec3 col;\r\n\r\n    float x = uv.x * 1.2 + iTime * 0.2;\r\n\r\n    vec3 hue = (sin(vec3(x, x + pi2 * 0.33, x + pi2 * 0.66)) + vec3(1.0)) * 0.7;\r\n\r\n\r\n    // overlay mix\r\n    float thres = 0.7;\r\n    if (lum < thres)\r\n        col = hue * lum / thres;\r\n    else\r\n        col = vec3(1.0) - (vec3(1.0 - (lum - thres)) * (vec3(1.0) - hue));\r\n\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"Ddc3zs",name:"Dive into geometry by Deep4",shader:"// https://www.shadertoy.com/view/Ddc3zs\r\nprecision mediump float;\r\n\r\nvec3 Field(vec3 Pos)\r\n{\r\n\tPos *= .1;\r\n\r\n\tfor (int i = 0; i < 5; ++i)\r\n\t{\r\n\t\tPos = abs(fract((Pos.yzx * mat3(.8, .6, .0, -.6, .8, .0, .0, .0, 1.)) + vec3(.123, .456, .789) * float(i)) - .5) * 2.;\r\n\t}\r\n\r\n\tPos *= Pos;\r\n\treturn sqrt(Pos + Pos.yzx) * .33;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    vec3 Direction = vec3((fragCoord.xy - iResolution.xy * .5) / iResolution.x, 1.);\r\n\tvec3 Position = vec3(.5, .8, iTime * 3.);\r\n\tvec3 Color;\r\n\r\n    // Sound (see shadertoy.com/view/Xds3Rr)\r\n    float fft_SnareDrum;\r\n\r\n    for (int n = 95; n<512; n += 100)\r\n    {\r\n        fft_SnareDrum += texelFetch(iChannel0, ivec2(n, 0), 0).x;\r\n    }\r\n\r\n    fft_SnareDrum /= 2.;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tvec3 f2 = Field(Position + (fft_SnareDrum * .5));\r\n\t\tPosition += Direction * min(min(f2.x, f2.y), f2.z);\r\n\t\tColor += float(50 - i) / (f2 + .005);\r\n\t}\r\n\r\n\tColor = vec3(1. - 1. / (1. + Color * (-.06 * .0004)));\r\n\tColor *= Color * (fft_SnareDrum * 2.);\r\n\tfragColor = vec4(Color.r * 6., .0, fft_SnareDrum, 1.);\r\n}\r\n"},{id:"cljXWw",name:"Fork SoundEclip reverland 340 by reverland",shader:"// https://www.shadertoy.com/view/cljXWw\r\n// credit: https://www.shadertoy.com/view/4tGXzt\r\n\r\n#define BEATMOVE 1\r\n\r\nconst float FREQ_RANGE = 128.0;\r\nconst float PI = 3.1415;\r\nconst float RADIUS = 0.6;\r\nconst float BRIGHTNESS = 0.2;\r\nconst float SPEED = 0.1;\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat luma(vec3 color) {\r\n  return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat getfrequency(float x) {\r\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\r\n}\r\n\r\nfloat getfrequency_smooth(float x) {\r\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\r\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\r\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\r\n}\r\n\r\nfloat getfrequency_blend(float x) {\r\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\r\n}\r\n\r\nvec3 doHalo(vec2 fragment, float radius) {\r\n\tfloat dist = length(fragment);\r\n\tfloat ring = 1.0 / abs(dist - radius);\r\n\r\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tfloat angle = atan(fragment.x, fragment.y);\r\n\tcol += hsv2rgb( vec3( ( angle  + iTime ) / (PI * 2.), cos(iTime)*0.1+0.5, cos(iTime) * 0.1 +0.5 ) ) * ring * b;\r\n\r\n\tfloat frequency = max(getfrequency_blend(abs(angle / (4. * PI))), 0.2);\r\n\tcol *= frequency;\r\n\r\n\t// Black halo\r\n\tcol *= smoothstep(radius * 0.5, radius, dist);\r\n\r\n\treturn col;\r\n}\r\n\r\nvec3 doLine(vec2 fragment, float radius, float x, float p) {\r\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\r\n\r\n\tfloat freq = abs(fragment.x * p);\r\n\r\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\r\n\tcol = col * smoothstep(radius, radius * 1.0, abs(fragment.x));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 fragPos = fragCoord / iResolution.xy;\r\n\tfragPos = (fragPos - 0.5) * 2.0;\r\n    fragPos.x *= iResolution.x / iResolution.y;\r\n\r\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\r\n\tcolor += doHalo(fragPos, RADIUS);\r\n    color += doHalo(fragPos, 0.2);\r\n\r\n    float c = cos(iTime * SPEED);\r\n    float s = sin(iTime * SPEED);\r\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\r\n\t//color += doLine(rot, RADIUS, rot.x, 0.12);\r\n\r\n\tcolor += max(luma(color) - 1.0, 0.0);\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"3s23RV",name:"Cavitation by EnigmaCurry",shader:"// https://www.shadertoy.com/view/3s23R\r\n// Cavitation - EnigmaCurry\r\n// Adapted from Bubble Rings by tdhooper - https://www.shadertoy.com/view/WdB3Dw\r\n\r\n// --------------------------------------------------------\r\n// HG_SDF\r\n// https://www.shadertoy.com/view/Xs3GRB\r\n// --------------------------------------------------------\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a, float c, float t) {\r\n    p = cos(a+p.y+c*t) + sin(a+p.y)*p*vec2(acos(p.x/p.x), p.y);\r\n}\r\n\r\nfloat smax(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Spectrum colour palette\r\n// IQ https://www.shadertoy.com/view/ll2GD3\r\n// --------------------------------------------------------\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 16.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Main SDF\r\n// https://www.shadertoy.com/view/wsfGDS\r\n// --------------------------------------------------------\r\n\r\nvec4 inverseStereographic(vec3 p, out float k) {\r\n    k = 2.0/(1.0+dot(p,p));\r\n    return vec4(k*p,k-1.0);\r\n}\r\n\r\nfloat fTorus(vec4 p4) {\r\n    float d1 = length(p4.xy) / length(p4.zw) - 2.;\r\n    float d2 = length(p4.zw) / length(p4.xy) - 22.;\r\n    float d = d1 < 0.9 ? -d1 : d2;\r\n    d /= PI;\r\n    return d;\r\n}\r\n\r\nfloat fixDistance(float d, float k) {\r\n    float sn = sign(d);\r\n    d = abs(d);\r\n    d = d / k * 1.82;\r\n    d += 1.;\r\n    d = pow(d, .5);\r\n    d -= 1.;\r\n    d *= 5./3.;\r\n    d *= sn;\r\n    return d;\r\n}\r\n\r\nfloat time;\r\n\r\nfloat map(vec3 p) {\r\n    float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.);\r\n    float k;\r\n    vec4 p4 = inverseStereographic(p,k);\r\n    float c = sin(iTime/22.) * fft;\r\n    float t = mod(iTime / 12., 333.);\r\n    pR(p4.zy, time * -PI / 2., c, t);\r\n    pR(p4.xw, time * -PI / 2., c, t);\r\n\r\n    // A thick walled clifford torus intersected with a sphere\r\n\r\n    float d = fTorus(p4);\r\n    d = abs(d);\r\n    d -= .2;\r\n    d = fixDistance(d, k);\r\n    d = smax(d, length(p) - 1.85, .2);\r\n\r\n    return d;\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Rendering\r\n// --------------------------------------------------------\r\n\r\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\r\n    vec3 ww = normalize(ta - ro);\r\n    vec3 uu = normalize(cross(ww,up));\r\n    vec3 vv = normalize(cross(uu,ww));\r\n    return mat3(uu, vv, ww);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n    time = mod(iTime / 1., 10.);\r\n\r\n    vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;\r\n    vec3 camTar = vec3(.0,0.,.0);\r\n    vec3 camUp = vec3(-18,0,-5.5);\r\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\r\n    float focalLength = 5.;\r\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y;\r\n\r\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 12.;\r\n\r\n    float distance = 0.;\r\n    vec3 color = vec3(0);\r\n\r\n    vec3 c;\r\n\r\n    // Keep iteration count too low to pass through entire model,\r\n    // giving the effect of fogged glass\r\n    const float ITER = 82.;\r\n    const float FUDGE_FACTORR = .8;\r\n    const float INTERSECTION_PRECISION = .001;\r\n    const float MAX_DIST = 20.;\r\n\r\n    for (float i = 0.; i < ITER; i++) {\r\n\r\n        // Step a little slower so we can accumilate glow\r\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        distance = map(rayPosition);\r\n\r\n        // Add a lot of light when we're really close to the surface\r\n        c = vec3(max(0., .01 - abs(distance)) * .5);\r\n        c *= vec3(1.4,2.1,1.7); // blue green tint\r\n\r\n        // Accumilate some purple glow for every step\r\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\r\n        c *= smoothstep(20., 7., length(rayPosition));\r\n\r\n        // Fade out further away from the camera\r\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\r\n        c *= rl;\r\n\r\n        // Vary colour as we move through space\r\n        c *= spectrum(rl * 6. - .6);\r\n\r\n        color += c;\r\n\r\n        if (rayLength > MAX_DIST) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Tonemapping and gamma\r\n    color = pow(color, vec3(1. / 1.8)) * 2.;\r\n    color = pow(color, vec3(2.)) * 3.;\r\n    color = pow(color, vec3(1. / 2.2));\r\n\r\n    fragColor = vec4(color, 1);\r\n}\r\n"},{id:"fllSD8",name:"Psychedelic Eye by mrange",shader:"// https://www.shadertoy.com/view/fllSD8\r\n// License CC0: Psychedelic eye\r\n//  Continuation of weekend experiment\r\n\r\n#define PI            3.141592654\r\n#define TAU           (2.0*PI)\r\n#define TIME          iTime\r\n#define TTIME         (TAU*TIME)\r\n#define RESOLUTION    iResolution\r\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\r\n#define PCOS(x)       (0.5 + 0.5*cos(x))\r\n#define DOT2(x)       dot(x, x)\r\n#define BPERIOD       5.6\r\n#define MPERIOD       7.2\r\n#define FLIP          10.0\r\n\r\nconst vec2 iris_center = vec2(0.0, 0.28);\r\n\r\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\r\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\r\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\r\n}\r\n// Macro version of above to enable compile-time constants\r\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\r\n\r\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0));\r\nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0));\r\nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0));\r\nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25));\r\nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25));\r\nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\r\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\r\nconst vec3  light0_dir    = normalize(light0_pos);\r\nconst vec3  light1_dir    = normalize(light1_pos);\r\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\r\n\r\nint   g_eff = 0;\r\n\r\nfloat g_hf;\r\n\r\nvec2 g_vx = vec2(0.0);\r\nvec2 g_vy = vec2(0.0);\r\n\r\nvec2 g_wx = vec2(0.0);\r\nvec2 g_wy = vec2(0.0);\r\n\r\n\r\nvec4 alphaBlend(vec4 back, vec4 front) {\r\n  float w = front.w + back.w*(1.0-front.w);\r\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\r\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\r\n}\r\n\r\nvec3 alphaBlend(vec3 back, vec4 front) {\r\n  return mix(back, front.xyz, front.w);\r\n}\r\n\r\nvec3 postProcess(vec3 col, vec2 q) {\r\n  col = clamp(col, 0.0, 1.0);\r\n  col = pow(col, vec3(1.0/2.2));\r\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\r\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\r\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\r\n  return col;\r\n}\r\n\r\nfloat circle(vec2 p, float r) {\r\n  return length(p) - r;\r\n}\r\n\r\n// Based on: https://iquilezles.org/articles/distfunctions2d\r\nfloat vesica(vec2 p, vec2 sz) {\r\n  if (sz.x < sz.y) {\r\n    sz = sz.yx;\r\n  } else {\r\n    p  = p.yx;\r\n  }\r\n  vec2 sz2 = sz*sz;\r\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\r\n  float r  = sqrt(sz2.x+d*d);\r\n  float b  = sz.x;\r\n  p = abs(p);\r\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\r\n                           : length(p-vec2(-d,0.0))-r;\r\n}\r\n\r\n// IQ's box\r\nfloat box(vec2 p, vec2 b) {\r\n  vec2 d = abs(p)-b;\r\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nfloat eye_shape(vec2 p) {\r\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/BPERIOD)));\r\n  const float w = 1.14;\r\n  float h = mix(0.48, 0.05, a);\r\n  float d0 =  vesica(p, vec2(w, h));\r\n  return d0;\r\n}\r\n\r\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\r\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\r\n  vec3 oc = ro - sph.xyz;\r\n  float b = dot( oc, rd );\r\n  float c = dot( oc, oc ) - sph.w*sph.w;\r\n  float h = b*b - c;\r\n  if (h < 0.0) return vec2(-1.0);\r\n  h = sqrt(h);\r\n  return vec2(-b - h, -b + h);\r\n}\r\n\r\n// IQ's ray plane intersect: https://iquilezles.org/articles/intersectors\r\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\r\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\r\n}\r\n\r\nfloat tanh_approx(float x) {\r\n//  return tanh(x);\r\n  float x2 = x*x;\r\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\r\n}\r\n\r\nvec2 toPolar(vec2 p) {\r\n  return vec2(length(p), atan(p.y, p.x));\r\n}\r\n\r\nvec2 toRect(vec2 p) {\r\n  return p.x*vec2(cos(p.y), sin(p.y));\r\n}\r\n\r\nvec3 toSpherical(vec3 p) {\r\n  float r   = length(p);\r\n  float t   = acos(p.z/r);\r\n  float ph  = atan(p.y, p.x);\r\n  return vec3(r, t, ph);\r\n}\r\n\r\nvec3 toRect(vec3 p) {\r\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\r\n}\r\n\r\n// https://mercury.sexy/hg_sdf/\r\nfloat mod1(inout float p, float size) {\r\n  float halfsize = size*0.5;\r\n  float c = floor((p + halfsize)/size);\r\n  p = mod(p + halfsize, size) - halfsize;\r\n  return c;\r\n}\r\n\r\n// https://mercury.sexy/hg_sdf/\r\nvec2 mod2(inout vec2 p, vec2 size) {\r\n  vec2 c = floor((p + size*0.5)/size);\r\n  p = mod(p + size*0.5,size) - size*0.5;\r\n  return c;\r\n}\r\n\r\n// https://iquilezles.org/articles/smin\r\nfloat pmin(float a, float b, float k) {\r\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n  return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nfloat pmax(float a, float b, float k) {\r\n  return -pmin(-a, -b, k);\r\n}\r\n\r\nfloat pabs(float a, float k) {\r\n  return -pmin(-a, a, k);\r\n}\r\n\r\nfloat noise(vec2 p) {\r\n  float a = sin(p.x);\r\n  float b = sin(p.y);\r\n  float c = 0.5 + 0.5*cos(p.x + p.y);\r\n  float d = mix(a, b, c);\r\n  return d;\r\n}\r\n\r\n// https://iquilezles.org/articles/fbm\r\nfloat fbm(vec2 p, float aa) {\r\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\r\n\r\n  float f = 0.0;\r\n  float a = 1.0;\r\n  float s = 0.0;\r\n  float m = 2.0;\r\n  for (int x = 0; x < 4; ++x) {\r\n    f += a*noise(p);\r\n    p = frot*p*m;\r\n    m += 0.01;\r\n    s += a;\r\n    a *= aa;\r\n  }\r\n  return f/s;\r\n}\r\n\r\n// https://iquilezles.org/articles/warp\r\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\r\n  const float r  = 0.5;\r\n  const float rr = 0.25;\r\n  float l2 = length(p);\r\n  float f  = 1.0;\r\n\r\n  if (g_eff==0) {\r\n//    f = smoothstep(r, r+rr, l2);\r\n    f = smoothstep(-0.1, 0.15, eye_shape(p));\r\n    p.y += TIME*0.125;\r\n    p.x = pabs(p.x, 0.1);\r\n  } else if (g_eff==1) {\r\n    const float z = 0.75;\r\n    f = smoothstep(-0.05, 0.1, eye_shape(p.yx/z)*z);\r\n    f = smoothstep(r, r+rr, l2);\r\n    p = -p.yx;\r\n    p = toPolar(p);\r\n//    f = smoothstep(r, r+rr, l2);\r\n    p.y -= -0.125*TIME+p.x*1.25;\r\n  }\r\n\r\n  g_hf = f;\r\n  vec2 pp = p;\r\n\r\n  vec2 vx = g_vx;\r\n  vec2 vy = g_vy;\r\n\r\n  vec2 wx = g_wx;\r\n  vec2 wy = g_wy;\r\n\r\n\r\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\r\n  float aa = 0.5;\r\n\r\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\r\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\r\n\r\n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\r\n}\r\n\r\nvec3 normal(vec2 p) {\r\n  vec2 v;\r\n  vec2 w;\r\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\r\n\r\n  vec3 n;\r\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\r\n  n.y = 2.0*e.x;\r\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\r\n\r\n  return normalize(n);\r\n}\r\n\r\nvoid compute_globals() {\r\n  vec2 vx = vec2(0.0, 0.0);\r\n  vec2 vy = vec2(3.2, 1.3);\r\n\r\n  vec2 wx = vec2(1.7, 9.2);\r\n  vec2 wy = vec2(8.3, 2.8);\r\n\r\n  vx *= ROT(TTIME/1000.0);\r\n  vy *= ROT(TTIME/900.0);\r\n\r\n  wx *= ROT(TTIME/800.0);\r\n  wy *= ROT(TTIME/700.0);\r\n\r\n  g_vx = vx;\r\n  g_vy = vy;\r\n\r\n  g_wx = wx;\r\n  g_wy = wy;\r\n}\r\n\r\nvec3 iris(vec2 p) {\r\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\r\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\r\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\r\n\r\n  vec3 ro = vec3(0.0, 10.0, 0.0);\r\n  vec3 pp = vec3(p.x, 0.0, p.y);\r\n\r\n  vec2 v;\r\n  vec2 w;\r\n\r\n  float h  = warp(p, v, w);\r\n  float hf = g_hf;\r\n  vec3  n  = normal(p);\r\n\r\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0));\r\n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\r\n  vec3 po  = vec3(p.x, 0.0, p.y);\r\n  vec3 rd  = normalize(po - ro);\r\n\r\n  vec3 ld1 = normalize(lp1 - po);\r\n  vec3 ld2 = normalize(lp2 - po);\r\n\r\n  float diff1 = max(dot(n, ld1), 0.0);\r\n  float diff2 = max(dot(n, ld2), 0.0);\r\n\r\n  vec3  ref   = reflect(rd, n);\r\n  float ref1  = max(dot(ref, ld1), 0.0);\r\n  float ref2  = max(dot(ref, ld2), 0.0);\r\n\r\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\r\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\r\n\r\n  float a = length(p);\r\n  vec3 col = vec3(0.0);\r\n//  col += hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\r\n//  col += hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\r\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\r\n//  col += (length(v)*col1 + length(w)*col2*1.0);\r\n//  col += diff1;\r\n//  col += diff2;\r\n//  col *= 0.0;\r\n  col += 0.5*lcol1*pow(ref1, 20.0);\r\n  col += 0.5*lcol2*pow(ref2, 10.0);\r\n  col *= hf;\r\n\r\n//  col = n;\r\n  return col;\r\n}\r\n\r\nvec3 eye_complete(vec2 p) {\r\n  const float iris_outer = 0.622;\r\n  const float iris_inner = 0.285;\r\n\r\n\r\n  float t0 = abs(0.9*p.x);\r\n  t0 *= t0;\r\n  t0 *= t0;\r\n  t0 *= t0;\r\n  t0 = clamp(t0, 0.0, 1.0);\r\n  float dt0 = mix(0.0125, -0.0025, t0);\r\n\r\n  vec2 p0 = p;\r\n  float d0 = eye_shape(p);\r\n  float d5 = d0;\r\n\r\n  vec2 p1 = p;\r\n  p1 -= iris_center;\r\n  float d1 = circle(p1, iris_outer);\r\n  d1 = max(d1,d0+dt0);\r\n  float d6 = d1;\r\n\r\n  vec2 p2 = p;\r\n  p2 -= vec2(0.155, 0.35);\r\n  float d2 = circle(p2, 0.065);\r\n\r\n  vec2 p3 = p;\r\n  p3 -= iris_center;\r\n  p3 = toPolar(p3);\r\n  float n3 = mod1(p3.x, 0.05);\r\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\r\n\r\n  vec2 p4 = p;\r\n  p4 -= iris_center;\r\n  float d4 = circle(p4, iris_inner);\r\n\r\n  d3 = max(d3,-d4);\r\n\r\n  d1 = pmax(d1,-d2, 0.0125);\r\n  d1 = max(d1,-d3);\r\n\r\n  d0 = abs(d0)-dt0;\r\n\r\n\r\n  float d = d0;\r\n  d = pmin(d, d1, 0.0125);\r\n  return vec3(d, d6, d5);\r\n}\r\n\r\nvec3 df(vec2 p) {\r\n  return eye_complete(p);\r\n}\r\n\r\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\r\n  rd.xy *= ROT(-PI/2.0+0.6);\r\n  vec3 srd = toSpherical(rd.xzy);\r\n  srd.z += 0.025*TIME;\r\n  vec2 pg  = srd.yz;\r\n  float f  = sin(pg.x);\r\n  float lf2= ceil(log(f)/log(2.0)-0.505);\r\n  float mf = pow(2.0, lf2);\r\n\r\n  float aa = 0.005;\r\n  const float count = 20.0;\r\n  const vec2 sz = vec2(2.0*PI/count);\r\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\r\n\r\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\r\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\r\n\r\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\r\n\r\n  vec2 pi = raySphere(ro, rd, planet_sph);\r\n\r\n  float lf1 = 1.0;\r\n  if (pi.x > 0.0) {\r\n    vec3 ppos = ro+rd*pi.x;\r\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\r\n    sky *= mix(0.5, 1.0, t);\r\n    lf1 = t;\r\n  } else {\r\n    sky += lines;\r\n  }\r\n\r\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color;\r\n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1;\r\n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color;\r\n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1;\r\n\r\n\r\n  return sky;\r\n}\r\n\r\nvec4 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\r\n  vec4 plane = vec4(normalize(vec3(1.0, 0.165-0.00, 0.0)), -0.944);\r\n  float aa = TTIME/MPERIOD;\r\n  float bb = smoothstep(-0.125, 0.125, sin(aa));\r\n  plane.xy *= ROT(0.075*bb);\r\n  plane.xz *= ROT(0.25*bb*sign(-sin(PI/4.0+0.5*aa)));\r\n  vec3 tnor  = plane.xyz;\r\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\r\n  float t = rayPlane(ro, rd, plane);\r\n  if (t <= 0.0) {\r\n    return vec4(0.0);\r\n  }\r\n\r\n  vec3 tpos = ro + t*rd;\r\n  tpos *= 4.0;\r\n  vec3 txx = normalize(cross(tnor, tup));\r\n  vec3 tyy = normalize(cross(tnor, txx));\r\n\r\n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\r\n\r\n  vec3 col = iris(tpos2)*smoothstep(0.0, 1.0/75.0, t);\r\n\r\n  return vec4(col, smoothstep(0.0, 1.0/500.0, t));\r\n}\r\n\r\n\r\nvec4 render_body(vec2 p, vec3 dd, float z) {\r\n//  p -= iris_center;\r\n  float aa = 2.0/RESOLUTION.y;\r\n\r\n  vec3 ro = vec3(2.0, 0.0, 0.0);\r\n  vec3 la = vec3(0.0, 0.0, 0.0);\r\n\r\n  vec2 np   = p + vec2(4.0/RESOLUTION.y);\r\n\r\n  vec3 ww   = normalize(la - ro);\r\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\r\n  vec3 vv   = normalize(cross(ww,uu));\r\n  float rdd = 2.0;\r\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\r\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\r\n\r\n  vec4 sph  = vec4(vec3(0.0), 1.0);\r\n\r\n  vec2 si   = raySphere(ro, rd, sph);\r\n  if (si.x <= 0.0) {\r\n    return vec4(0.0);\r\n  }\r\n\r\n  float a = smoothstep(-aa, aa, -dd.z);\r\n  float b = smoothstep(0.0, mix(0.25, 1.0, float(p.y > 0.0))*mix(0.075, 0.0025, smoothstep(0.5, 1.0, abs(p.x))), -dd.z/z);\r\n  float c = smoothstep(-aa, aa, -dd.x);\r\n\r\n  vec3 pos  = ro + rd*si.x;\r\n\r\n  vec3 nor  = normalize(pos - sph.xyz);\r\n\r\n  float dif0= max(dot(nor, light0_dir), 0.0);\r\n  float dif1= max(dot(nor, light1_dir), 0.0);\r\n\r\n  vec3 ref  = reflect(rd, nor);\r\n  vec3 nref = reflect(nrd, nor);\r\n\r\n  vec3 refr = refract(rd, nor, 0.9);\r\n  vec3 nrefr= refract(nrd, nor, 0.9);\r\n\r\n  vec3 rbkg = render_background(pos, ref, nref);\r\n  vec4 riris= render_iris(pos, refr, nrefr);\r\n\r\n  vec3 col = vec3(0.0);\r\n  col += vec3(0.5);\r\n  col += dif1*0.5;\r\n  col += dif0*0.5;\r\n  if (fract((TIME/BPERIOD)/(2.0*FLIP)) > 0.5) {\r\n    rbkg = max(rbkg, 0.0);\r\n    rbkg = tanh(vec3(0.5, 1.0, 1.6)*rbkg).zxy;\r\n    col = mix(rbkg, rbkg*0.6, c);\r\n  } else {\r\n    col = alphaBlend(col, riris);\r\n    col += rbkg*mix(0.33, 1.0, riris.w);\r\n  }\r\n  col *= b;\r\n\r\n  return vec4(col, a);\r\n}\r\n\r\nfloat synth(vec2 p) {\r\n  const float z = 4.0;\r\n  const float st = 0.02;\r\n  float dob = box(p, vec2(1.4, 0.5));\r\n  p.x = abs(p.x);\r\n  p.x += st*20.0;\r\n  p /= z;\r\n  float n = mod1(p.x, st);\r\n  float dib = 1E6;\r\n  const int around = 1;\r\n  for (int i = -around; i <=around ;++i) {\r\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x;\r\n    fft *= fft;\r\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\r\n    dib = min(dib, dibb);\r\n  }\r\n\r\n  float dl = p.y;\r\n  dl = abs(dl) - 0.005;\r\n  dl = abs(dl) - 0.0025;\r\n  dl = abs(dl) - 0.00125;\r\n  float d = dib;\r\n  d = max(d, -dl);\r\n  //d = pmax(d, dob, 0.025);\r\n  return d*z;\r\n}\r\n\r\nvec3 effect(vec2 p) {\r\n  compute_globals();\r\n\r\n  float aa = 2.0/RESOLUTION.y;\r\n  const float m = 3.0;\r\n  const float z = 1.0;\r\n  p /= z;\r\n  vec2 pp  = p;\r\n\r\n  vec3 d   = df(pp)*z;\r\n\r\n  vec4 dcol = vec4(mix(vec3(0.9), vec3(0.0), smoothstep(-aa, aa, -d.x)) , smoothstep(-aa, aa, -d.z));\r\n  g_eff = 1;\r\n  vec4 scol = render_body(p, d, z);\r\n\r\n  vec3 col  = vec3(1.0);\r\n  g_eff = 0;\r\n  col = iris(p);\r\n\r\n  vec2 dp = p;\r\n  dp.y = -pabs(dp.y, 1.0);\r\n  dp -= vec2(0.0, -0.85);\r\n  dp = toPolar(dp);\r\n  dp.y += -0.2*(p.x);\r\n  dp = toRect(dp);\r\n  float dd = synth(dp);\r\n\r\n  vec4 ddcol = vec4(vec3(0.9), smoothstep(-aa, aa, -dd));\r\n\r\n  col = alphaBlend(col, dcol);\r\n  if (fract((TIME/BPERIOD)/FLIP) > 0.5) {\r\n    col = alphaBlend(col, scol);\r\n  }\r\n  col -= 0.5*exp(-75.0*max(dd, 0.0));\r\n  col = alphaBlend(col, ddcol);\r\n  return col;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n  vec2 q = fragCoord/iResolution.xy;\r\n  vec2 p = -1.0 + 2.0*q;\r\n  p.x *= RESOLUTION.x/RESOLUTION.y;\r\n  float aa = 2.0/RESOLUTION.y;\r\n\r\n  vec3 col = effect(p);\r\n  col = mix(vec3(0.0), col, smoothstep(0.5, 5.0, TIME));\r\n  col = postProcess(col, q);\r\n\r\n  fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"4stSRs",name:"Abstract Music by MatHack",shader:"// https://www.shadertoy.com/view/4stSRs\r\n//Fast Code, No Optim and clean ;) !\r\n\r\nfloat freqs[16];\r\n\r\n\r\nmat2 rotate2d(float angle){\r\n    return mat2(cos(angle),-sin(angle),\r\n                sin(angle),cos(angle));\r\n}\r\n\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 47.0;\r\n    return fract(cos(f*3.333)*100003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(cos(f*3.333)*100003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\n\r\nfloat PI=3.14159265;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xx;\r\n    vec2 mouse = iMouse.xy / iResolution.xy;\r\n    vec2 uv2 =  -1.0 + 2.0 * uv;\r\n    uv2.y += 0.45;\r\n    //uv2.xy -= (mouse*4.0) - 2.0;\r\n    uv2.xy *= 4.5;\r\n\r\n    float time = iTime + (2.0*freqs[0]);\r\n\r\n    vec3 color = vec3(0.0);\r\n    vec3 color2 = vec3(0.0);\r\n\r\n    float nbPointX = 128.0;\r\n    float nbPointY = 128.0;\r\n    float resX =  (iResolution.x/nbPointX)/iResolution.x;\r\n    float resY =  (iResolution.y/nbPointY)/iResolution.y;\r\n\r\n\r\n    for( int i=0; i<16; i++ ){\r\n        freqs[i] = clamp( 1.9*pow( texture( iChannel0, vec2( 0.05 + 0.5*float(i)/16.0, 0.25 ) ).x, 3.0 ), 0.0, 1.0 );\r\n\r\n        float wave = sqrt(sin( (-(freqs[i]*noise2d(uv*10.0+ vec2(rotate2d(iTime)).xy ) )*3.1416) + ((uv2.x*uv2.x) + (uv2.y*uv2.y)) ) );\r\n\r\n\t\tvec2 v = rotate2d(iTime) * (uv * 2.0);\r\n\r\n \t\twave = smoothstep(0.8, 1.0, wave);\r\n        color2 += wave * (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) * freqs[i];\r\n\r\n        float endPixelX = (1.0/iResolution.x)*(wave*1.0);\r\n    \tfloat endPixelY = (1.0/iResolution.x)*(wave*1.0);\r\n        //Grid 1\r\n        if(mod(uv.x, resX) >= 0.0 && mod(uv.x, resX) <= endPixelX && mod(uv.y, resY) >= 0.0 && mod(uv.y, resY) <= endPixelY){\r\n            color2 += (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) ;\r\n        }\r\n\r\n\r\n        wave = smoothstep(0.99999, 1.0, wave);\r\n        color2 += wave * vec3(0.2) ;\r\n\r\n\r\n    }\r\n\r\n\r\n\tfragColor =  vec4(color2, 1.0);\r\n\r\n\r\n}\r\n"},{id:"MdfBz7",name:"Particles Dance by MatHack",shader:"// https://www.shadertoy.com/view/MdfBz7\r\n#define M_PI 3.1415926535897932384626433832795\r\n\r\nfloat random(vec2 co)\r\n{\r\n    highp float a = 12.9898;\r\n    highp float b = 78.233;\r\n    highp float c = 43758.5453;\r\n    highp float dt= dot(co.xy ,vec2(a,b));\r\n    highp float sn= mod(dt,3.14);\r\n    return fract(sin(sn) * c);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec4 outColor = vec4(0.0);\r\n\tfloat time = iTime * 0.1;\r\n    vec2 uvNorm = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = -0.5 + 1.0 * uvNorm;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\r\n\r\n    for(float i=0.0; i<600.0 ;i++){\r\n        float f1 = mod(i * 0.101213, 0.28);\r\n        float fft1 = texture(iChannel0, vec2(f1)).x;\r\n        float r = (fft1 / 2.);\r\n        float r1 = (fft1 / 8.) * random(vec2(uv));\r\n        float a = random(vec2(i))*(M_PI*2.);\r\n        vec2 center = vec2(cos(a), sin(a)) * r;\r\n        vec2 center2 = vec2(cos(a), sin(a)) * r1;\r\n        float dist = length(uv - center);\r\n        float dist2 = length(uv - center - center2);\r\n        float birghtness = 1./pow(0.001 + dist*350., 2.);\r\n        float birghtness2 = 1./pow(0.001 + dist2*500., 2.);\r\n        vec3 color = vec3(fft1-0.8, 0.3, fft1-0.2);\r\n        vec3 col = color * birghtness2 * fft1 * 2.;\r\n        col += color * birghtness * fft1 * 1.5;\r\n        //Out :D\r\n        outColor.rgb += col;\r\n    }\r\n\r\n\r\n    float grid = smoothstep((sin(length(uv.y-0.5)*(800.*length(uv.y+0.5))) * sin(length(uv.x+0.5)*(800.*length(uv.x-0.5)))), 0.0, 1.0);\r\n    outColor.rgb += (outColor.rgb * vec3(grid) * 0.6);\r\n\r\n\tfragColor = outColor;\r\n}\r\n"},{id:"WsGfDm",name:"osc + equalizer by chernomord",shader:"// https://www.shadertoy.com/view/WsGfDm\r\nconst float PI = 3.14;\r\n\r\nfloat plot(vec2 st, float pct){\r\n  return  smoothstep( pct-0.015, pct, st.y) -\r\n          smoothstep( pct, pct+0.015, st.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    // Time varying pixel color\r\n    vec4 col = vec4( 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\r\n    vec4 top = texture(iChannel0, vec2(uv.x,1.));\r\n    float pl = plot(uv,top.r);\r\n    vec4 osc=vec4(vec3(pl),1.);\r\n\r\n\r\n    uv.y = abs(uv.y*2.-1.);\r\n    osc.b /= 10.*uv.y;\r\n    osc.g /=5.*uv.y;\r\n\r\n    // Output to screen\r\n    // compress X coord\r\n    float comp = floor(uv.x*80.)/80.;\r\n    float ultraComp = floor(uv.y*1.)/1.;\r\n\r\n    vec4 backgrCol = texture(iChannel0, vec2(ultraComp, 0.));\r\n    backgrCol.b = backgrCol.r / (uv.y*10.*uv.x)/2.;\r\n    backgrCol.g = backgrCol.r / (uv.y*6.*uv.x)/8.;\r\n    backgrCol.r = backgrCol.r / (uv.y*8.*uv.x)/1.;\r\n\r\n    // get texture from channel0\r\n    fragColor = texture(iChannel0, vec2(comp, 0.));\r\n    // colorize texture\r\n    fragColor.g = sin(fragColor.r*PI);\r\n    fragColor.b = abs(fragColor.r - 1.);\r\n\r\n    fragColor *= step(uv.y, fragColor.r);\r\n    fragColor = fragColor/1.2 + osc;\r\n    fragColor = fragColor + backgrCol/4.;\r\n}\r\n"},{id:"sdjGWG",name:"SoundStar by atutahi",shader:"// https://www.shadertoy.com/view/sdjGWG\r\n#define PI 3.14159\r\n\r\nfloat expStep( float x, float k, float n )\r\n{\r\n    return exp( -k*pow(x,n) );\r\n}\r\n\r\nfloat cubicPulse( float c, float w, float x )\r\n{\r\n    x = abs(x - c);\r\n    if( x>w ) return 0.0;\r\n    x /= w;\r\n    return 1.0 - x*x*(3.0-2.0*x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // create pixel coordinates\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n    // diag symmetry\r\n    // uv = length(uv.x + uv.y) < 1. ? uv : vec2(1.0 - uv.x, 1.0 - uv.y);\r\n\r\n    // abs uv symmetry\r\n    // uv = abs(uv * 2. - 1.);\r\n\r\n    vec2 coords = uv;\r\n\r\n    uv = uv * 2. - 1.;\r\n    uv *= 2.;\r\n    uv.x += 0.6;\r\n\r\n    float ro = length(uv) - 0.05 * sin(iTime * 3.);\r\n    float angle = atan(uv.y, uv.x);  // atan2\r\n    vec2 range = vec2(-1. * PI, 1. * PI);  // The range of atan2 is [-pi / 1; pi / 1]\r\n    float theta = smoothstep(range[0], range[1], angle);  // Normalize the range of atan to [0;1]\r\n    theta = abs(2. * theta - 1.);\r\n    theta += sin(iTime * 0.1) * 0.3;\r\n\r\n    uv = vec2(theta, ro);\r\n\r\n\t// first texture row is frequency data\r\n\r\n    float fftFrequency = .1;\r\n    float fftCoord = sin(uv.x * fftFrequency) * uv.x;\r\n\tfloat fft  = texture( iChannel0, vec2(fftCoord,0.25) ).x * 1.1;\r\n\r\n    // second texture row is the sound wave\r\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75) ).x * 0.1;\r\n\r\n    float spectrumScale = 1.;\r\n    float spectrum = 1.0 - smoothstep(fft - 0.2, fft, uv.y * spectrumScale);\r\n\r\n    vec3 col = vec3(0.0);\r\n\r\n    // add wave form\r\n    float corol = (1.0 -  smoothstep( 0.0, coords.x, abs(wave - uv.y + coords.x * 0.2 + fft) ));\r\n\r\n    // add fft\r\n\tcol += vec3(1.0,fft,fft-.4) * (spectrum + corol) * (.5 + ro);\r\n\r\n\t// output final color\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"4dycW1",name:"Audio Spectrum by isak",shader:"// https://www.shadertoy.com/view/4dycW1\r\nfloat audio_power_f( in sampler2D channel, in float f, in float p) {\r\n    return texture( channel, vec2(f, p) ).x;\r\n}\r\n\r\n#define audio_power(x) audio_power_f(iChannel0, x, 0.0)\r\n#define audio_power_p(x,p) audio_power_f(iChannel0, x, p)\r\n#define pi 3.141592\r\n\r\nvec3 freq_bar(vec2 FC) {\r\n    vec2 uv = FC.xy / iResolution.xy;\r\n    float power = audio_power(uv.x);\r\n\r\n \treturn smoothstep(power, 0.0, uv.y)*vec3(power,0.5,0.5);\r\n}\r\n\r\nvec3 freq_circle(vec2 FC) {\r\n \tvec2 uv = FC.xy - 0.5*iResolution.xy;\r\n    uv *= 2.0/iResolution.y;\r\n\r\n    float angle = sign(uv.x)*atan(uv.x,uv.y);\r\n\r\n    float power, power_c;\r\n    power_c = 1.0 - audio_power_p(angle/pi, 1.0) ;\r\n    power = audio_power( angle/pi );\r\n\r\n    uv = 0.2*uv/(1.0- (1.7 + 0.3*power_c)*length(uv));\r\n\r\n\r\n\r\n    float ref_size = 0.2;\r\n    vec3 color;\r\n    float shade;\r\n    shade = smoothstep(0.2,power*0.8 + 0.25, length(uv));\r\n    shade *= smoothstep(0.0, 0.2+ 0.5*power, (1.0 - length(uv)));\r\n\r\n    color = vec3(power*power_c, power*0.5 + 0.5, power_c + 0.4);\r\n    return shade*color;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 FC ) {\r\n\r\n\r\n    fragColor = vec4(freq_bar(FC), 1.0);\r\n    fragColor = vec4(freq_circle(FC), 1.0);\r\n\r\n}\r\n"},{id:"XsyXzw",name:"Dancing Dots by s23b",shader:"// https://www.shadertoy.com/view/XsyXz\r\n#define PI 3.14159265359\r\n\r\nvec3 hsv2rgb (in vec3 hsv) {\r\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\r\n}\r\n\r\nfloat hash(vec3 uv) {\r\n    return fract(sin(dot(uv, vec3(7.13, 157.09, 113.57))) * 48543.5453);\r\n}\r\n\r\n// better distance function thanks to Shane\r\nfloat map(vec3 p) {\r\n    float radius = texture(iChannel0, vec2(hash(floor(p)), .25)).x * .99 + .01;\r\n    return length(fract(p) - .5) - .25 * radius;\r\n}\r\n\r\n// raymarching function\r\nfloat trace(vec3 o, vec3 r) {\r\n\r\n    float t = 0.;\r\n\r\n    for (int i = 0; i < 32; ++i) { // Low iterations for blur.\r\n        float d = map(o + r * t);\r\n        t += d * .9; // Ray shortening to blur a bit more.\r\n    }\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // ray\r\n    vec3 r = normalize(vec3(uv, 2.));\r\n    // origin\r\n    vec3 o = vec3(-3, iTime, -1);\r\n\r\n    // rotate origin and ray\r\n    float a = -iTime * .5;\r\n    mat2 rot = mat2(cos(a), -sin(a), sin(a), cos(a));\r\n    o.xz *= rot;\r\n    r.xy *= rot;\r\n    r.xz *= rot;\r\n\r\n    // march\r\n    float f = trace(o, r);\r\n\r\n    // calculate color from angle on xz plane\r\n    vec3 p = o + f * r;\r\n    float angel = atan(p.x, p.z) / PI / 2.;\r\n    vec3 c = hsv2rgb(vec3(angel, 1., 1.));\r\n\r\n    // add with fog\r\n\tfragColor = vec4(c / (1. + f * f * .1),1.0);\r\n}\r\n"},{id:"7ltyR4",name:"Playing around with spirals by mati_software",shader:"// https://www.shadertoy.com/view/7ltyR4\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 spiralCenter = iResolution.xy / 2.0;\r\n    float abstandSpiralCenter = distance(fragCoord, spiralCenter);\r\n    float abstandSpiralCenterNorm = abstandSpiralCenter / length(iResolution.xy / 2.0);\r\n\r\n    float winkel = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .17)   + iTime * .61;\r\n    vec2 vergleichspunkt = spiralCenter + abstandSpiralCenter * vec2(sin(winkel), cos(winkel));\r\n    float abstandVergleichspunkt = distance(fragCoord, vergleichspunkt);\r\n    float abstandVergleichspunktNorm = abstandVergleichspunkt / length(iResolution.xy / 2.0);\r\n    float subtrahend = abstandVergleichspunktNorm / abstandSpiralCenterNorm;\r\n\r\n    float winkel2 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .23 + .1)   + iTime * .31;\r\n    vec2 vergleichspunkt2 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel2), cos(winkel2));\r\n    float abstandVergleichspunkt2 = distance(fragCoord, vergleichspunkt2);\r\n    float abstandVergleichspunktNorm2 = abstandVergleichspunkt2 / length(iResolution.xy / 2.0);\r\n    float subtrahend2 = abstandVergleichspunktNorm2 / abstandSpiralCenterNorm;\r\n\r\n    float winkel3 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .41 + .62)   + iTime * .47;\r\n    vec2 vergleichspunkt3 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel3), cos(winkel3));\r\n    float abstandVergleichspunkt3 = distance(fragCoord, vergleichspunkt3);\r\n    float abstandVergleichspunktNorm3 = abstandVergleichspunkt3 / length(iResolution.xy / 2.0);\r\n    float subtrahend3 = abstandVergleichspunktNorm3 / abstandSpiralCenterNorm;\r\n\r\n    float winkel4 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .38 + .17)   + iTime * .85;\r\n    vec2 vergleichspunkt4 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel4), cos(winkel4));\r\n    float abstandVergleichspunkt4 = distance(fragCoord, vergleichspunkt4);\r\n    float abstandVergleichspunktNorm4 = abstandVergleichspunkt4 / length(iResolution.xy / 2.0);\r\n    float subtrahend4 = abstandVergleichspunktNorm4 / abstandSpiralCenterNorm;\r\n\r\n    float winkel5 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .48 + .95)   + iTime * .57;\r\n    vec2 vergleichspunkt5 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel5), cos(winkel5));\r\n    float abstandVergleichspunkt5 = distance(fragCoord, vergleichspunkt5);\r\n    float abstandVergleichspunktNorm5 = abstandVergleichspunkt5 / length(iResolution.xy / 2.0);\r\n    float subtrahend5 = abstandVergleichspunktNorm5 / abstandSpiralCenterNorm;\r\n\r\n    float winkel6 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .29 + .27)   + iTime * .54;\r\n    vec2 vergleichspunkt6 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel6), cos(winkel6));\r\n    float abstandVergleichspunkt6 = distance(fragCoord, vergleichspunkt6);\r\n    float abstandVergleichspunktNorm6 = abstandVergleichspunkt6 / length(iResolution.xy / 2.0);\r\n    float subtrahend6 = abstandVergleichspunktNorm6 / abstandSpiralCenterNorm;\r\n\r\n    vec3 fragColor1 = vec3(2.0 - abstandVergleichspunktNorm - abstandVergleichspunktNorm4 - abstandVergleichspunktNorm6, 2.0 - abstandVergleichspunktNorm2 - abstandVergleichspunktNorm5 - abstandVergleichspunktNorm4, 2.0 - abstandVergleichspunktNorm3 - abstandVergleichspunktNorm6 - abstandVergleichspunktNorm5);\r\n    vec3 fragColor2 = vec3(4.0 - subtrahend - subtrahend4 - subtrahend6, 4.0 - subtrahend2 - subtrahend5 - subtrahend4, 4.0 - subtrahend3 - subtrahend6 - subtrahend5);\r\n    float faktor = texture(iChannel0,vec2(0,0)).x;\r\n    faktor = pow(faktor, 5.0);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(mix(fragColor1, fragColor2, faktor), 1.0);\r\n}\r\n"},{id:"ls3BDH",name:"SoundEclipse rpm by sclavel",shader:"// https://www.shadertoy.com/view/ls3BDH\r\n// credit: https://www.shadertoy.com/view/4tGXzt\r\n\r\n#define BEATMOVE 1\r\n\r\nconst float FREQ_RANGE = 64.0;\r\nconst float PI = 3.1415;\r\nconst float RADIUS = 0.6;\r\nconst float BRIGHTNESS = 0.2;\r\nconst float SPEED = 0.5;\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat luma(vec3 color) {\r\n  return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat getfrequency(float x) {\r\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\r\n}\r\n\r\nfloat getfrequency_smooth(float x) {\r\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\r\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\r\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\r\n}\r\n\r\nfloat getfrequency_blend(float x) {\r\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\r\n}\r\n\r\nvec3 doHalo(vec2 fragment, float radius) {\r\n\tfloat dist = length(fragment);\r\n\tfloat ring = 1.0 / abs(dist - radius);\r\n\r\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\r\n\r\n\tvec3 col = vec3(0.0);\r\n\r\n\tfloat angle = atan(fragment.x, fragment.y);\r\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\r\n\r\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\r\n\tcol *= frequency;\r\n\r\n\t// Black halo\r\n\tcol *= smoothstep(radius * 0.5, radius, dist);\r\n\r\n\treturn col;\r\n}\r\n\r\nvec3 doLine(vec2 fragment, float radius, float x) {\r\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\r\n\r\n\tfloat freq = abs(fragment.x * 0.5);\r\n\r\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\r\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 fragPos = fragCoord / iResolution.xy;\r\n\tfragPos = (fragPos - 0.5) * 2.0;\r\n    fragPos.x *= iResolution.x / iResolution.y;\r\n\r\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\r\n\tcolor += doHalo(fragPos, RADIUS);\r\n\r\n    float c = cos(iTime * SPEED);\r\n    float s = sin(iTime * SPEED);\r\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\r\n\tcolor += doLine(rot, RADIUS, rot.x);\r\n\r\n\tcolor += max(luma(color) - 1.0, 0.0);\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"llB3W1",name:"Fractal Audio 01 by relampago2048",shader:"// https://www.shadertoy.com/view/llB3W1\r\nconst int iters = 150;\r\n\r\nint fractal(vec2 p, vec2 point) {\r\n\tvec2 so = (-1.0 + 2.0 * point) * 0.4;\r\n\tvec2 seed = vec2(0.098386255 + so.x, 0.6387662 + so.y);\r\n\r\n\tfor (int i = 0; i < iters; i++) {\r\n\r\n\t\tif (length(p) > 2.0) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t\tvec2 r = p;\r\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\r\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nvec3 color(int i) {\r\n\tfloat f = float(i)/float(iters) * 2.0;\r\n\tf=f*f*2.;\r\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\r\n}\r\n\r\n\r\nfloat sampleMusicA() {\r\n\treturn 0.5 * (\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 mouse = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\r\n\r\n    vec2 position = 3. * (-0.5 + fragCoord.xy / iResolution.xy );\r\n\tposition.x *= iResolution.x/iResolution.y;\r\n\r\n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);\r\n    vec2 pos2 = 2. * (-0.5 + iFC.xy / iResolution.xy);\r\n    pos2.x*=iResolution.x/iResolution.y;\r\n\r\n    vec4 t3 = texture(iChannel0, vec2(length(position)/2.0,0.1) );\r\n    float pulse = 0.5+sampleMusicA()*1.8;\r\n\r\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime/3.+0.5)/2.0,pulse*.9)));\r\n\r\n    vec3 fract4 = color(fractal(position/1.6,vec2(0.6+cos(iTime/2.+0.5)/2.0,pulse*.8)));\r\n\r\n    vec3 c = color(fractal(position,vec2(0.5+sin(iTime/3.)/2.0,pulse)));\r\n\r\n    t3=abs(vec4(0.5,0.1,0.5,1.)-t3)*2.;\r\n\r\n    vec4 fract01 =  vec4( c , 1.0 );\r\n    vec4 salida;\r\n    salida = fract01 / t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.3);\r\n\tfragColor = salida;\r\n}\r\n"},{id:"Ws2fWG",name:"Ocassional Spectators by Kali",shader:"// https://www.shadertoy.com/view/Ws2fWG\r\n\r\nfloat s;\r\nfloat t;\r\nvec3 ot;\r\nvec3 colo=vec3(0);\r\n\r\nmat2 rot(float a) {\r\n  float s=sin(a),c=cos(a);\r\n  return mat2(c,s,-s,c);\r\n}\r\n\r\nfloat de(vec3 p)\r\n{\r\n  float z=p.z;\r\n  ot=vec3(100);\r\n  colo=p;\r\n  float sc=1.;\r\n  p.xy*=rot(p.z*.1);\r\n  p=abs(15.-mod(p,30.))-1.;\r\n  for (int i=0; i<8; i++) {\r\n    p.xy*=rot(1.);\r\n    p.yz*=rot(t*10.);\r\n    ot=min(ot,abs(p.xyz));\r\n    p.xy=abs(p.xy+5.)-abs(p.xy-5.)-p.xy;\r\n    float s=1.5;\r\n    sc*=s;\r\n    p=p*s;\r\n  }\r\n  colo=exp(-15.*ot);\r\n  return (length(p)/sc-.5)*.8;\r\n\r\n}\r\n\r\n\r\nvec3 march(vec3 from, vec3 dir) {\r\n  float d, td=0.;\r\n  vec3 p, c=vec3(0.);\r\n  for (int i=0; i<50; i++)\r\n  {\r\n    p=from+dir*td;\r\n    d=de(p);\r\n    td+=max(.01,abs(d));\r\n    c+=colo*exp(-.05*td);\r\n  }\r\n  return (c*c*.02);\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  t=floor(iChannelTime[0]*10.)*.001;\r\n  s=texture(iChannel0,vec2(.3)).r;\r\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\r\n  uv-=.5;\r\n  uv.x*=iResolution.x/iResolution.y;\r\n  if (fract(t*4.)<.5) t+=floor(length(uv)*4.-t*100.); else t+=floor(length(uv.y+uv.x)*1.5-t*100.);\r\n  vec3 dir=normalize(vec3(uv,.5+s*.3));\r\n  vec3 from=vec3(cos(t*.5)*2.,sin(t)*2.,t*200.);\r\n  from.xy*=rot(t*100.);\r\n  dir.yz*=rot(smoothstep(-.5,.5,sin(t*10.))*10.);\r\n  vec3 c = march(from,dir);\r\n  c=abs(cross(c,dir));\r\n  c.xy*=rot(t*50.+s*20.);\r\n  fragColor = vec4(c,1.)*min(1.,iChannelTime[0]*.2);\r\n}\r\n"}].map((({id:r,name:n,shader:e})=>({providerId:"ampshader",name:n,externalUrl:`https://www.shadertoy.com/view/${r}`,shader:`#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n#extension GL_EXT_shader_texture_lod : enable\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\nuniform vec4 iTheme;\r\nuniform float iTime;\r\nuniform float iChannelTime[4];\r\nuniform vec4 iDate;\r\nuniform vec2 iResolution;\r\nuniform sampler2D iChannel0;\r\nuniform sampler2D iChannel1;\r\nuniform sampler2D iChannel2;\r\nuniform sampler2D iChannel3;\r\nuniform float iSampleRate;\r\nuniform float iTimeDelta;\r\nuniform float iChannelResolution[4];\r\nvec3 iMouse = vec3(0., 0., 0.);\r\n#define iFrame (floor(iTime / 60))\r\nfloat round( float x ) { return floor(x+0.5); }\r\nvec2 round(vec2 x) { return floor(x + 0.5); }\r\nvec3 round(vec3 x) { return floor(x + 0.5); }\r\nvec4 round(vec4 x) { return floor(x + 0.5); }\r\nvec4 texture(sampler2D s, vec2 c) { return texture2D(s,c); }\r\nvec4 texture(sampler2D s, vec2 c, float b) { return texture2D(s,c,b); }\r\nvec4 texture(samplerCube s, vec3 c ) { return textureCube(s,c); }\r\nvec4 texture(samplerCube s, vec3 c, float b) { return textureCube(s,c,b); }\r\nvec4 textureLod(sampler2D s, vec2 c, float b) { return texture2DLodEXT(s,c,b); }\r\nvec4 textureGrad(sampler2D s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\r\nvec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\r\nfloat sinh(float x) { return (exp(x)-exp(-x))/2.; }\r\nvec2 sinh(vec2 x) { return (exp(x)-exp(-x))/2.; }\r\nvec3 sinh(vec3 x) { return (exp(x)-exp(-x))/2.; }\r\nvec4 sinh(vec4 x) { return (exp(x)-exp(-x))/2.; }\r\nfloat cosh(float x) { return (exp(x)+exp(-x))/2.; }\r\nvec2 cosh(vec2 x) { return (exp(x)+exp(-x))/2.; }\r\nvec3 cosh(vec3 x) { return (exp(x)+exp(-x))/2.; }\r\nvec4 cosh(vec4 x) { return (exp(x)+exp(-x))/2.; }\r\nfloat tanh(float x) { return sinh(x)/cosh(x); }\r\nvec2 tanh(vec2 x) { return sinh(x)/cosh(x); }\r\nvec3 tanh(vec3 x) { return sinh(x)/cosh(x); }\r\nvec4 tanh(vec4 x) { return sinh(x)/cosh(x); }\r\n\n${e}\nvoid main() {\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}\r\n`})))}}]);